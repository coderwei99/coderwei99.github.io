<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>undefined的细节</title>
      <link href="/post/fbb5ddc9.html"/>
      <url>/post/fbb5ddc9.html</url>
      
        <content type="html"><![CDATA[<h2 id="undefined的几个特性"><a href="#undefined的几个特性" class="headerlink" title="undefined的几个特性"></a>undefined的几个特性</h2><blockquote><p>undefined 是window下的一个属性，即使一个原始数据类型，也是一个原始值数据</p></blockquote><ol><li><p>不可写</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">undefined</span>) <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">undefined</span> = <span class="string">&#x27;coderwei&#x27;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">undefined</span>) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></li><li><p>不可配置</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">delete</span> <span class="variable language_">window</span>.<span class="property">undefined</span> </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">undefined</span>) <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></li><li><p>不可枚举</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">in</span> <span class="variable language_">window</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (item === <span class="literal">undefined</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">//不会输出</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//补充 既然不可枚举 那我们使用Object.defineProperty定义window下面的undefined 使其变成可枚举的属性，可以嘛？ 实际上浏览器会给我抛出异常，告诉我们undefined是不可重新定义</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h2><ul><li><p>当我们定义一个变量为对他进行赋值的时候，浏览器会帮我们给他赋值一个undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure></li><li><p>同样的当我们函数定义的形参的时候，如果没有对其赋值，也会打印出undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params">a</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a); <span class="comment">//undefined</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>()</span><br></pre></td></tr></table></figure></li><li><p>undefined在局部作用域下是可以用来作为变量的，<wavy>意味着undefined并没有作为保留字或者是关键字 即便是严格模式下亦是如此</wavy> </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="literal">undefined</span> = <span class="string">&#x27;hello word&#x27;</span> <span class="comment">//全局作用域下定义的undefined 用let会报错 重复声明 用var第二行则输入undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>) <span class="comment">//undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> <span class="literal">undefined</span> = <span class="string">&#x27;coderwei&#x27;</span></span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="literal">undefined</span>); <span class="comment">//coderwei</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>博客常用语法</title>
      <link href="/post/99e51e06.html"/>
      <url>/post/99e51e06.html</url>
      
        <content type="html"><![CDATA[<h3 id="文本样式"><a href="#文本样式" class="headerlink" title="文本样式"></a>文本样式</h3><u>文本内容</u><emp>文本内容</emp><wavy>文本内容</wavy><del>文本内容</del><kbd>文本内容</kbd><psw>文本内容</psw><h3 id="行内文本样式-text"><a href="#行内文本样式-text" class="headerlink" title="行内文本样式 text"></a>行内文本样式 text</h3><ol><li>带 <u>下划线</u> 的文本</li><li>带 <emp>着重号</emp> 的文本</li><li>带 <wavy>波浪线</wavy> 的文本</li><li>带 <del>删除线</del> 的文本</li><li>键盘样式的文本 <kbd>command</kbd> + <kbd>D</kbd></li><li>密码样式的文本：<psw>这里没有验证码</psw></li></ol><h3 id="专栏博客链接样式"><a href="#专栏博客链接样式" class="headerlink" title="专栏博客链接样式"></a>专栏博客链接样式</h3><div class='checkbox'><input type="radio" />            <p>纯文本测试</p>            </div><div class='checkbox checked'><input type="radio" checked="checked"/>            <p>支持简单的 <a href="https://guides.github.com/features/mastering-markdown/">markdown</a> 语法</p>            </div><div class='checkbox red'><input type="radio" />            <p>支持自定义颜色</p>            </div><div class='checkbox green'><input type="radio" />            <p>绿色</p>            </div><div class='checkbox yellow'><input type="radio" />            <p>黄色</p>            </div><div class='checkbox cyan'><input type="radio" />            <p>青色</p>            </div><div class='checkbox blue'><input type="radio" />            <p>蓝色</p>            </div>]]></content>
      
      
      <categories>
          
          <category> hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue3核心实现专栏</title>
      <link href="/post/370f26c0gghe.html"/>
      <url>/post/370f26c0gghe.html</url>
      
        <content type="html"><![CDATA[<div class='checkbox'><input type="radio" />            <p><a href="">Vue3的响应式原理(理论篇)</a></p>            </div>]]></content>
      
      
      <categories>
          
          <category> Vue </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript进阶指南</title>
      <link href="/post/456961af.html"/>
      <url>/post/456961af.html</url>
      
        <content type="html"><![CDATA[<div class='checkbox'><input type="radio" />            <p><a href="">你所不知道的undefined</a></p>            </div>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>call、apply、bind</title>
      <link href="/post/f4bc1432.html"/>
      <url>/post/f4bc1432.html</url>
      
        <content type="html"><![CDATA[<h1 id="手写call、apply、bind方法"><a href="#手写call、apply、bind方法" class="headerlink" title="手写call、apply、bind方法"></a>手写call、apply、bind方法</h1><h2 id="call方法"><a href="#call方法" class="headerlink" title="call方法"></a>call方法</h2><p>call、apply和bind方法我们都知道是用来绑定this的，那么它内部做了什么事情呢？其实也不复杂，对于call来说总结下来也就五步</p><ol><li>在封装的call函数内部需要拿到需要绑定的函数</li><li>然后将传进来的第一个参数，也就是this转换为对象，顺手判断一下是否为undefined或者是null。因为原生call方法传入这两个参数绑定的是window</li><li>然后将这个对象加入一个属性，value就是拿到的函数</li><li>利用隐式绑定调用一下这个函数，调用完就可以删除掉这个函数了</li><li>最后将结果返回出去即可</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1. call的实现：</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(a + b + c);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//利用ES6提供的剩余参数</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">weiCall</span> = <span class="keyword">function</span> (<span class="params">thisArg, ...arg</span>) &#123;</span><br><span class="line"><span class="comment">//edge case，判断传入的参数是否合法</span></span><br><span class="line">  thisArg =</span><br><span class="line">    thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span> ? <span class="title class_">Object</span>(thisArg) : <span class="variable language_">window</span>;</span><br><span class="line">  thisArg.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> result = thisArg.<span class="title function_">fn</span>(...arg);</span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line">foo.<span class="title function_">weiCall</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;coderwei&quot;</span> &#125;, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>); <span class="comment">//coderwei,6</span></span><br></pre></td></tr></table></figure><blockquote><p>因为我们在调用的时候就是通过函数名.weiCall的形式调用的，所以这里会进行隐式绑定，weiCall这个函数内部的this就是我们需要的函数</p></blockquote><h2 id="apply方法"><a href="#apply方法" class="headerlink" title="apply方法"></a>apply方法</h2><p>apply和call一样，都是用来绑定this指向的，他们不同点在于后面传递的参数不同，call方法传递的参数是是以逗号分隔的，而apply方法传入的是一个数组。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 2. apply 函数的实现</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">weiApply</span> = <span class="keyword">function</span> (<span class="params">thisArg, arg</span>) &#123;</span><br><span class="line">  thisArg =</span><br><span class="line">    thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span> ? <span class="title class_">Object</span>(thisArg) : <span class="variable language_">window</span>;</span><br><span class="line"></span><br><span class="line">  thisArg.<span class="property">fn</span> = <span class="variable language_">this</span>;</span><br><span class="line">  <span class="keyword">const</span> result = thisArg.<span class="title function_">fn</span>(...arg);</span><br><span class="line">  <span class="keyword">delete</span> thisArg.<span class="property">fn</span>;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">foo.<span class="title function_">weiApply</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;coderwei&quot;</span> &#125;, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br></pre></td></tr></table></figure><blockquote><p>所以weiApply方法的第二个参数不需要用剩余参数来接收，因为他就两个参数，一个this的指向，一个数组</p><p>但是执行函数的时候我们需要用展开运算符将数组展开作为函数的参数</p></blockquote><h2 id="bind方法"><a href="#bind方法" class="headerlink" title="bind方法"></a>bind方法</h2><p>bind方法需要注意一点，因为bind方法返回的是一个函数，所以说他可以在绑定的时候传递两个参数，在执行的执行把剩余一个参数传递进来。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. bind函数的实现</span></span><br><span class="line"><span class="title class_">Function</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">weiBind</span> = <span class="keyword">function</span> (<span class="params">thisArg, ...arg</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> _this = <span class="variable language_">this</span>;</span><br><span class="line">  thisArg =</span><br><span class="line">    thisArg !== <span class="literal">null</span> &amp;&amp; thisArg !== <span class="literal">undefined</span> ? <span class="title class_">Object</span>(thisArg) : <span class="variable language_">window</span>;</span><br><span class="line">  <span class="comment">// 返回一个函数，依旧是接收不定量的参数</span></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">...arg2</span>) &#123;</span><br><span class="line">    <span class="comment">// 将所有参数拼接到一个数组中</span></span><br><span class="line">    <span class="keyword">const</span> allArg = [...arg, ...arg2];</span><br><span class="line">    thisArg.<span class="property">fn</span> = _this;</span><br><span class="line">    <span class="comment">// 将所有参数展开挨个传入函数中</span></span><br><span class="line">    <span class="keyword">const</span> result = thisArg.<span class="title function_">fn</span>(...allArg);</span><br><span class="line">    <span class="keyword">delete</span> thisArg.<span class="property">fn</span>;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> bar = foo.<span class="title function_">weiBind</span>(&#123; <span class="attr">name</span>: <span class="string">&quot;coderwei&quot;</span> &#125;, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="title function_">bar</span>(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>this指向</title>
      <link href="/post/74520f03.html"/>
      <url>/post/74520f03.html</url>
      
        <content type="html"><![CDATA[<h1 id="JS中的this指向总结"><a href="#JS中的this指向总结" class="headerlink" title="JS中的this指向总结"></a>JS中的this指向总结</h1><h2 id="为什么会出现this"><a href="#为什么会出现this" class="headerlink" title="为什么会出现this"></a>为什么会出现this</h2><p>首先在学习this到底指向谁之前，先要知道为什么要有this？实际上从某些角度来说，即便没有this也无伤大雅，我们先看个例子。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;coderwei&quot;</span>,</span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span> + <span class="string">&quot;在跑步&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">sleep</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span> + <span class="string">&quot;在睡觉&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">study</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">name</span> + <span class="string">&quot;在学习&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">running</span>(); <span class="comment">//coderwei在跑步</span></span><br><span class="line">obj.<span class="title function_">sleep</span>(); <span class="comment">//coderwei在睡觉</span></span><br><span class="line">obj.<span class="title function_">study</span>(); <span class="comment">//coderwei在学习</span></span><br></pre></td></tr></table></figure><p>在这个例子中，我们会发现，即便不用this，也不影响我们代码的正常执行，但是如果有一天obj这个对象的名字发生了变化，那么内部的所有obj都要换成对应的名字，否则就找不到这个对象了，这样就会影响我们代码的正常运行。所以我们就需要一个对象，能够指向他自身，那么这个时候this就理所当然的出现了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;coderwei&quot;</span>,</span><br><span class="line">  <span class="title function_">running</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;在跑步&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">sleep</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;在睡觉&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">study</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span> + <span class="string">&quot;在学习&quot;</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">running</span>(); <span class="comment">//coderwei在跑步</span></span><br><span class="line">obj.<span class="title function_">sleep</span>(); <span class="comment">//coderwei在睡觉</span></span><br><span class="line">obj.<span class="title function_">study</span>(); <span class="comment">//coderwei在学习</span></span><br></pre></td></tr></table></figure><p>我们会神奇的发现代码照常运行，并没有任何问题，更神奇的是这个this还是动态绑定的，这也是this那么晦涩难懂的原因，他在不同的情况下会有不同的绑定规则。</p><h2 id="this的绑定规则"><a href="#this的绑定规则" class="headerlink" title="this的绑定规则"></a>this的绑定规则</h2><blockquote><p>以下绑定规则都是在非严格模式下</p><p>如果没有指明在什么环境下，默认都是在浏览器环境下</p></blockquote><h3 id="全局作用域下的this到底指向谁？"><a href="#全局作用域下的this到底指向谁？" class="headerlink" title="全局作用域下的this到底指向谁？"></a>全局作用域下的this到底指向谁？</h3><p>首先我们需要知道，this的指向和所处的环境有关，在浏览器下面和在node环境下指向的是不同的东西，具体有什么区别在实际案例中会指出，首先我们先看下面例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br></pre></td></tr></table></figure><p>我们只是单纯的输出一下this，会发现在浏览器下面运行这段js脚本输出的是<strong>window</strong>，而在node环境下输出的是一个空对象({}),首先在浏览器下，这个this指向浏览器的window对象，这没什么好说的，在node环境下为什么会指向一个空对象？那是因为node是commonjs的最成功的实践者，他内部使用commonjs的模式开发，他将每个文件都分成一个模块，而这个this就是使用了call绑定到一个变量<strong>thisValue</strong>，看下面这行图片</p><p><img src="https://i.bmp.ovh/imgs/2021/11/1a6b5bd9031b483d.png" alt="node源码"></p><p>那么问题来了，this.exports有是一个什么东西呢？继续看下面这一张图片</p><p><img src="https://i.bmp.ovh/imgs/2021/11/f632e2b69ba1ac6e.png" alt="this.exports"></p><p>显而易见，这个东西就是一个空对象。我的理解是这个空对象实际上就是module.exports，如果我的理解有误，可以随时联系提醒我。</p><h3 id="默认绑定"><a href="#默认绑定" class="headerlink" title="默认绑定"></a>默认绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">//window</span></span><br></pre></td></tr></table></figure><p>我们会发现这里的this在浏览器环境下指向window，而在node环境下这里的this指向<strong>global</strong>全局对象。其实在判断函数的this指向的时候，我们第一点需要判断的是他是不是一个独立的函数调用，如果是，那么都是指向window的。</p><p>看这个例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;coderwei&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> bar = obj.<span class="property">foo</span>;</span><br><span class="line"><span class="title function_">bar</span>(); <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p>一样的，不用去管bar对象是谁给的，怎么给的，就看他是怎么调用的，前面赋值在写的花里胡哨，只需要永远记得，this是在执行的时候动态绑定的，只要你的调用的是一个单独的函数调用，那么这个this就是指向window。</p><h3 id="隐式绑定"><a href="#隐式绑定" class="headerlink" title="隐式绑定"></a>隐式绑定</h3><p>隐式绑定在实际开发中也很常见，是通过某个对象调用的，这个时候会进行一个隐式绑定。</p><blockquote><p>函数和方法</p><p>在js中，方法和函数有什么区别？我们主要看这个函数是不是独立的，如果他是独立的，那么我们将他称之为函数，如若不然，我们将他称之为方法。举个例子，在对象中的函数我们通常称之为方法，因为他始终和这个对象联系在一起，调用也是通过这个对象调用的</p></blockquote><p>看下面例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">//&#x27;&#x27;,因为window对象上本来就有个name属性，所以打印出来是一个空字符串</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;coderwei&quot;</span>,</span><br><span class="line">  foo,</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">foo</span>(); <span class="comment">//coderwei</span></span><br></pre></td></tr></table></figure><p>在执行foo函数的时候，通过obj对象调用的，所以this会动态绑定到obj对象上，这就是一个典型的隐式绑定的例子。所以还是那句话，一定要关注函数调用的位置，他怎么被调用的，this指向的关键在这个位置。</p><h3 id="显式绑定"><a href="#显式绑定" class="headerlink" title="显式绑定"></a>显式绑定</h3><p>首先我们先看看在js中函数有几种调用方式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;函数执行&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">//函数执行</span></span><br><span class="line">foo.<span class="title function_">call</span>(); <span class="comment">//函数执行</span></span><br><span class="line">foo.<span class="title function_">apply</span>(); <span class="comment">//函数执行</span></span><br></pre></td></tr></table></figure><p>我们会发现上面三种调用方式，都会执行函数，那么下面两种方式存在的意义是什么？js发展至今，只要某个语法存在，那么必定有他存在的意义，不然早就被抛弃的。区别在于this指向的问题，下面两种调用方式我们可以手动的绑定一个对象作为this的指向，还有一种bind方法，也是绑定this的，但是他并不会执行这个函数，后续我会单独出一篇文章探讨call、apply和bind方法并且使用js自己实现一下这三个方法。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj  = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;coderwei&#x27;</span>,</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>() <span class="comment">// &#x27;&#x27;</span></span><br><span class="line">foo.<span class="title function_">call</span>(obj) <span class="comment">//coderwei</span></span><br><span class="line">foo.<span class="title function_">apply</span>(obj) <span class="comment">//coderwei</span></span><br><span class="line"><span class="keyword">let</span> bar = foo.<span class="title function_">bind</span>(obj) <span class="comment">//bind方法只绑定不执行，绑定好后返回一个新的函数，以后这个函数的this</span></span><br><span class="line"><span class="comment">//就是bind的第一个参数</span></span><br><span class="line"><span class="title function_">bar</span>() <span class="comment">//coderwei</span></span><br></pre></td></tr></table></figure><p>我们会发现使用call或者是apply的方式调用，输出的结果和直接调用是不用的，他们的this指向的是call函数的第一个参数。当然会有第二个参数，第二个参数也是这两个方法不同的地方。这里我们就不做探讨，一起放到后面专门讲这几个方法的文章中</p><blockquote><p>小提示</p><p>如果call、apply、bind绑定了一个null或者是undefined，那么默认会绑定到window，应该是实现这几个函数的时候内部做了边界判断</p></blockquote><h3 id="new绑定"><a href="#new绑定" class="headerlink" title="new绑定"></a>new绑定</h3><p>new操作符涉及到面向对象的概念，也是js实现面向对象的基础。首先对于new操作符在内部做了什么，我们就直接上结论，我们主要关注使用new操作符之后，我的this指向谁了？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">这里我们需要注意一个细节，通常情况下构造函数我们会以大写字母开头，用于和普通的函数做一个区分，</span></span><br><span class="line"><span class="comment">因为他们都是用function定义的。果然，不遵守这个规范也无可厚非，从代码运行的层面来说，他并不会影</span></span><br><span class="line"><span class="comment">响代码的正常运行，主要是加以区分方便日后的开发者和自己进行维护</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br></pre></td></tr></table></figure><p>这里我们需要注意一个细节，通常情况下<strong>构造函数</strong>我们会以大写字母开头，用于和普通的函数做一个区分，因为他们都是用function定义的。果然，不遵守这个规范也无可厚非，从代码运行的层面来说，他并不会影响代码的正常运行，主要是加以区分方便日后的开发者和自己进行维护</p><h4 id="this指向谁了"><a href="#this指向谁了" class="headerlink" title="this指向谁了"></a>this指向谁了</h4><ol><li>在内存中创建一个对象p1</li><li>将People的prototype赋值给p1._<em>proto_</em></li><li>将创建出来的对象p1和构造函数内部的this进行一个绑定</li><li>处理内部代码</li><li>return 这个对象出去(函数内部没有返回其他对象</li></ol><p>new操作符我们主要关注this绑定的问题，在内部会将p1对象的this绑定到函数调用的this上面。</p><h4 id="构造函数的this"><a href="#构造函数的this" class="headerlink" title="构造函数的this"></a>构造函数的this</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;coderwei&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>); <span class="comment">//true  验证上面第二点</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="property">name</span>);  <span class="comment">//coderwei</span></span><br></pre></td></tr></table></figure><h3 id="内置函数的this"><a href="#内置函数的this" class="headerlink" title="内置函数的this"></a>内置函数的this</h3><ol><li><p>forEach</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.  只传递一个参数</span></span><br><span class="line"><span class="keyword">let</span> items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">items.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item, <span class="variable language_">this</span>); <span class="comment">// 我们会发现这里的this指向的是window</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2. 传递两个参数</span></span><br><span class="line"><span class="keyword">let</span> items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">items.<span class="title function_">forEach</span>(<span class="keyword">function</span> (<span class="params">item</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item, <span class="variable language_">this</span>); <span class="comment">// 我们会发现这里的this指向的是coderwei</span></span><br><span class="line">&#125;,<span class="string">&#x27;coderwei&#x27;</span>);</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>当然类似的方法也有map、filter等等，需要注意的是这里不能写成箭头函数，因为箭头函数不绑定this的。</p></li><li><p>setTimeout</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;, <span class="number">200</span>);</span><br></pre></td></tr></table></figure><p>这个位置的this指向的也是window，但是这里有个特殊的点，看下面代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">//undefined</span></span><br></pre></td></tr></table></figure><p>在严格模式下函数内部的this指向的是undefined。但是放到setTimeout上，事情就变得不一样了。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>); <span class="comment">// window</span></span><br><span class="line">&#125;, <span class="number">200</span>); </span><br></pre></td></tr></table></figure><p>诡异吧，这个this指向的还是window，这个点笔者没有办法证明是如何实现的，如果有其他朋友有思路的可以指出。我的猜测是内部处理setTimeout的时候，对这个函数并不是直接执行，而是执行了一个bind方法，这个在翻阅资料的时候看到过一篇文章，在V8的测试文件中关于setTimeout的片段的注释中提到了一嘴bind。</p></li></ol><h2 id="this绑定的优先级"><a href="#this绑定的优先级" class="headerlink" title="this绑定的优先级"></a>this绑定的优先级</h2><h3 id="显式绑定vs隐式绑定"><a href="#显式绑定vs隐式绑定" class="headerlink" title="显式绑定vs隐式绑定"></a>显式绑定vs隐式绑定</h3><p>首先隐式绑定没有什么好说的，隐式绑定讲道理嘛，他就应该是最低的，他是内部自动绑定的，所以说只要你想改，无论用什么方式，都应该成功的改变this的指向</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="title function_">call</span>(<span class="string">&quot;coderwei&quot;</span>); <span class="comment">//coderwei</span></span><br><span class="line">foo.<span class="title function_">apply</span>(<span class="string">&quot;coderwei&quot;</span>);<span class="comment">//coderwei</span></span><br><span class="line"><span class="keyword">const</span> bar = foo.<span class="title function_">bind</span>(<span class="string">&quot;coderwei&quot;</span>);</span><br><span class="line"><span class="title function_">bar</span>();<span class="comment">//coderwei</span></span><br></pre></td></tr></table></figure><h3 id="隐式绑定VS-new绑定"><a href="#隐式绑定VS-new绑定" class="headerlink" title="隐式绑定VS new绑定"></a>隐式绑定VS new绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;coderwei&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.<span class="title function_">foo</span>(); <span class="comment">//  obj对象</span></span><br><span class="line"><span class="keyword">new</span> obj.<span class="title function_">foo</span>(); <span class="comment">// foo函数</span></span><br></pre></td></tr></table></figure><h3 id="显式绑定vs-new绑定"><a href="#显式绑定vs-new绑定" class="headerlink" title="显式绑定vs new绑定"></a>显式绑定vs new绑定</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> bar = foo.<span class="title function_">bind</span>(<span class="string">&quot;coderwei&quot;</span>);</span><br><span class="line"><span class="keyword">new</span> <span class="title function_">bar</span>();<span class="comment">// foo函数</span></span><br></pre></td></tr></table></figure><p>这里需要注意一点，call和apply不能被new实例化，所以他们之间无法比较优先级</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>new绑定优先级大于显式绑定</li><li>显式绑定优先级大于隐式绑定</li><li>隐式绑定优先级大于默认绑定</li></ol><h2 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h2><p>箭头函数是ES6新增的一种新的编写函数的方式，他会比以往编写函数的方式更加简单。</p><ul><li>箭头函数是不会绑定this的，他也没有arguments(在函数内部能够拿到的实参列表)</li><li>箭头函数不能当成构造函数来使用，因为他没有自己的this</li></ul><p>因为箭头函数没有this，所以它不适用上面的几钟规则，如果箭头函数内部使用到了this，他就需要去到外层作用域去找this</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;coderwei&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">foo</span>(); <span class="comment">//coderwei</span></span><br><span class="line"><span class="comment">//改造成箭头函数</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;coderwei&quot;</span>,</span><br><span class="line">  <span class="attr">foo</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj.<span class="title function_">foo</span>();<span class="comment">//&#x27;&#x27;还是那一点，window下面本来就有个name属性，所以是空字符串。本质上这里指向window</span></span><br></pre></td></tr></table></figure><h2 id="分析几道面试题"><a href="#分析几道面试题" class="headerlink" title="分析几道面试题"></a>分析几道面试题</h2><h3 id="第一道"><a href="#第一道" class="headerlink" title="第一道"></a>第一道</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;window&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;person&quot;</span>,</span><br><span class="line">  <span class="attr">sayName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayName</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> sss = person.<span class="property">sayName</span>;</span><br><span class="line">  <span class="title function_">sss</span>(); <span class="comment">//他就是一个独立的函数调用，前面在花里胡哨都不需要关心</span></span><br><span class="line">  person.<span class="title function_">sayName</span>();  <span class="comment">//隐式绑定不多说</span></span><br><span class="line">  (person.<span class="property">sayName</span>)();</span><br><span class="line">  (b = person.<span class="property">sayName</span>)();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayName</span>();</span><br><span class="line"><span class="comment">// window</span></span><br><span class="line"><span class="comment">//coderwei</span></span><br><span class="line"><span class="comment">//coderwei</span></span><br><span class="line"><span class="comment">//window</span></span><br></pre></td></tr></table></figure><p>这道题总的来说没多大难度，主要关注(person.sayName)()本质上还是通过person调用的，所以他的this还是指向person，(b = person.sayName)()这里他是一个自执行函数，也就是前面讲的独立的函数调用，所以说这里指向了window</p><h3 id="第二道"><a href="#第二道" class="headerlink" title="第二道"></a>第二道</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">&quot;window&quot;</span>;</span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;coderwei&quot;</span>,</span><br><span class="line">  <span class="attr">foo1</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo2</span>: <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>),</span><br><span class="line">  <span class="attr">foo3</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">foo4</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person2 = &#123; <span class="attr">name</span>: <span class="string">&quot;person2&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">foo1</span>();</span><br><span class="line">person.<span class="property">foo1</span>.<span class="title function_">call</span>(person2);</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">foo2</span>();</span><br><span class="line">person.<span class="property">foo2</span>.<span class="title function_">call</span>(person2);</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">foo3</span>()();</span><br><span class="line">person.<span class="property">foo3</span>.<span class="title function_">call</span>(person2)();</span><br><span class="line">person.<span class="title function_">foo3</span>().<span class="title function_">call</span>(person2);</span><br><span class="line"></span><br><span class="line">person.<span class="title function_">foo4</span>()();</span><br><span class="line">person.<span class="property">foo4</span>.<span class="title function_">call</span>(person2)();</span><br><span class="line">person.<span class="title function_">foo4</span>().<span class="title function_">call</span>(person2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// coderwei</span></span><br><span class="line"><span class="comment">// person2</span></span><br><span class="line"><span class="comment">// window</span></span><br><span class="line"><span class="comment">// window</span></span><br><span class="line"><span class="comment">// window</span></span><br><span class="line"><span class="comment">// window</span></span><br><span class="line"><span class="comment">// person2</span></span><br><span class="line"><span class="comment">// coderwei</span></span><br><span class="line"><span class="comment">// person2</span></span><br><span class="line"><span class="comment">// coderwei</span></span><br></pre></td></tr></table></figure><p>分析一下每一行的函数调用，</p><ul><li>在第一次调用的时候，我们直接通过一个对象去调用一个函数，这里会有一个默认绑定，所以结果是coderwei</li><li>第二次函数调用通过call的方法来调用，所以他会覆盖隐式绑定，以显示绑定为主，所以结果是person2</li><li>第三次函数调用是调用了一个箭头函数，<strong>箭头函数不绑定this</strong>，所以他回去外层作用域去找，外层作用域是全局，注意：对象没有作用域，不要把对象那个花括号当成一个作用域。</li><li>第四次函数调用通过call的方式来调用，但是咱们的箭头函数不绑定this，你给我，我还不要呢，所以他的this依旧去上层作用域找，所以还是window</li><li>第五次函数调用是返回了一个新的函数，实际上是拿到新的函数直接做一个调用，所以他就是一个独立的函数调用，结果显而易见，依旧是window</li><li>第六次函数调用是给foo3用call绑定了一个this，然后在执行内部返回的函数。但是我们只是给外部的函数绑定了一个this，关内部函数什么事情，本质上还是一个独立的函数调用，所以返回的还是一个window</li><li>第七次函数调用是先执行foo3函数，拿到返回的函数之后给这个函数绑定了this，所以结果是person2</li><li>第八次函数调用式是先调用foo4函数，然后拿到返回的函数后继续调用。但是需要注意的是返回的函数是一个箭头函数，所以他没有自己的this，他要去外层作用域找，他是被一个函数包裹的，函数是有作用域的，也就是说他拿到的是外层的函数的this，也就是我们前面进行隐式绑定的person2</li><li>第九次函数调用跟第八次一样，都是要去外层寻找this，不过这一次我们给外层的函数指定了this，是person2，所以他拿到的就是person2</li><li>第十次函数调用是拿到返回的箭头函数之后给这个箭头函数绑定this，箭头函数没有自己的this，也不能绑定this，所以说他依旧是去外层找，外层函数的this隐式绑定的person，也就是coderwei</li></ul><p>所以说箭头函数有点像一个二百五，我不管，我就是没有，你给我我也不要，我就要去上层作用域要，他是什么我就拿什么作为我的this。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ES Module</title>
      <link href="/post/dc521de2.html"/>
      <url>/post/dc521de2.html</url>
      
        <content type="html"><![CDATA[<h1 id="ES-Module的导入和导出"><a href="#ES-Module的导入和导出" class="headerlink" title="ES Module的导入和导出"></a>ES Module的导入和导出</h1><p>模块化的开发方式可以提高代码复用率，方便进行代码的管理。通常一个文件就是一个模块，有自己的作用域，只向外暴露特定的变量和函数。在早期的js没有模块化的概念。但是随着发展又需要模块化，于是出现了集中规范，早期比较出名的就有AMD、CMD，他们都只是一种规范，没有具体的实践，而AMD具体的实践者就有requirejs、curl，CMD则有seajs，不过随着历史的发展，这两种规范都慢慢的推出了历史的舞台，现在流行的commonjs 和ES6 Module，而node就是commonjs最佳的实践者，而ES Module则是官方规范的模块化，自然而然就是现在最主流的模块化方案，<a href="https://hacks.mozilla.org/2018/03/es-modules-a-cartoon-deep-dive/">ES Module的工作原理有一篇文章讲的非常好，如果对英文没有压力的话，我觉得非常有必要阅读一篇。</a></p><h2 id="export"><a href="#export" class="headerlink" title="export"></a>export</h2><h3 id="导出"><a href="#导出" class="headerlink" title="导出"></a>导出</h3><ol><li><p>第一种方法： </p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> name = <span class="string">&quot;coderwei&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> age = <span class="number">19</span>;</span><br></pre></td></tr></table></figure></li><li><p>第二种方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;coderwei&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">name,</span><br><span class="line">    age</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>第三种方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;coderwei&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">export</span> &#123;</span><br><span class="line">name <span class="keyword">as</span> fname,</span><br><span class="line">    age <span class="keyword">as</span> fage</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//这种方式不常用，如果需要起别名通常在导入的时候起别名</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="导入"><a href="#导入" class="headerlink" title="导入"></a>导入</h3><ol><li><p>第一种导入方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; name, age &#125; <span class="keyword">from</span> <span class="string">&quot;./01_导出的三种方式/01_导出的三种方式.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name, age);</span><br></pre></td></tr></table></figure></li><li><p>第二种导入方式：起别名</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  name <span class="keyword">as</span> fname,</span><br><span class="line">  age <span class="keyword">as</span> fage,</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&quot;./01_导出的三种方式/01_导出的三种方式.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(fname, fage);</span><br></pre></td></tr></table></figure></li><li><p>第三种导入方式：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> <span class="title class_">Info</span> <span class="keyword">from</span> <span class="string">&quot;./01_导出的三种方式/01_导出的三种方式.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Info</span>.<span class="property">name</span>, <span class="title class_">Info</span>.<span class="property">age</span>);</span><br></pre></td></tr></table></figure></li></ol><h3 id="结合使用"><a href="#结合使用" class="headerlink" title="结合使用"></a>结合使用</h3><p>​        结合实际项目，在开发中可以会有一个utils工具库，封装一些常用的工具函数，所以这个时候我们通常会给他定义一个统一的出口(index.js)，避免我们在导入的时候找来找去的，也方便后续进行管理。</p><ol><li><p>/utils/formatDate.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">formatDate</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>/utils/foramtPrice.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">formatPrice</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;￥&quot;</span> + <span class="string">&quot;99.99&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">rmbToGreenback</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">&quot;$&quot;</span> + <span class="string">&quot;99.99&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>/utils/index.js</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 导入导出方式1</span></span><br><span class="line"><span class="keyword">import</span> &#123; formatDate &#125; <span class="keyword">from</span> <span class="string">&quot;./formatDate.js&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; formatPrice, rmbToGreenback &#125; <span class="keyword">from</span> <span class="string">&quot;./formatPrice.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; formatDate, formatPrice, rmbToGreenback &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入导出方式2</span></span><br><span class="line"><span class="keyword">export</span> &#123; formatDate &#125; <span class="keyword">from</span> <span class="string">&quot;./formatDate.js&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; formatPrice, rmbToGreenback &#125; <span class="keyword">from</span> <span class="string">&quot;./formatPrice.js&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入导出方式3</span></span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./formatDate.js&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">&quot;./formatPrice.js&quot;</span>;</span><br></pre></td></tr></table></figure></li></ol><h2 id="export-default"><a href="#export-default" class="headerlink" title="export default"></a>export default</h2><p>​        export导出要求了我们导出的叫什么，导入的时候就一定要叫什么，不然的话就找不到了。当然我也可以给一个模块定义一个默认导出的内容，而这个默认导出的内容就是用export default声明的，再导入的时候也不需要关心导出的名字是什么，由开发者自己决定，同一个模块只能有一个默认导出的变量</p><h3 id="导出-1"><a href="#导出-1" class="headerlink" title="导出"></a>导出</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一种方式可以通过起别名的形式声明一个默认导出的变量，比如说</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;coderwei&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">19</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> &#123; name, age <span class="keyword">as</span> <span class="keyword">default</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种导出方式可以使用export default</span></span><br><span class="line"><span class="keyword">const</span> name = <span class="string">&quot;coderwei&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">19</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> age;</span><br></pre></td></tr></table></figure><h3 id="导入-1"><a href="#导入-1" class="headerlink" title="导入"></a>导入</h3><p>使用默认导出的时候，如果需要导入，需要省略中括号</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> coderwei <span class="keyword">from</span> <span class="string">&quot;./utils/index.js&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(coderwei); <span class="comment">//19</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事件循环</title>
      <link href="/post/b8084239.html"/>
      <url>/post/b8084239.html</url>
      
        <content type="html"><![CDATA[<h1 id="事件循环（EventLoop）"><a href="#事件循环（EventLoop）" class="headerlink" title="事件循环（EventLoop）"></a>事件循环（EventLoop）</h1><h3 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h3><p>在了解什么是js的事件循环之前，必须要弄清楚什么叫<strong>线程</strong>，什么又叫<strong>进程</strong>？当我们的电脑刚组装好，是没有办法使用的，这个时候我们就需要安装操作系统，操作系统就像是我们和硬件之间的桥梁。</p><ol><li>进程：进程是指计算机中已运行的程序，是分时系统的基本运作单位。这时维基百科对进程的解释，还是那句话，维基百科喜欢用概念解释概念，太抽象了。举个通俗的例子，我们的电脑每打开一个软件，就会开辟一个进程，用于服务这个软件</li><li>线程：线程是指操作系统能够进行运算调度最小的单位，大部分情况下他被包含在进程中。也就是说一个进程可以拥有多个线程。</li></ol><h3 id="事件队列"><a href="#事件队列" class="headerlink" title="事件队列"></a>事件队列</h3><p>我们都知道JavaScript是单线程语言，那么他遇到耗时的代码会如何处理呢？比如说有一个十秒的定时器，难不成站在那里等待？这明显不现实，所以这个时候就需要一个地方用于存放一些耗时的任务，我先继续往下面执行，等你该运行了我就回过头来执行其中的代码，那么问题又来了，这个队列由谁来维护？自然不可能是JavaScript，别忘记JavaScript是单线程的，如果是JavaScript来维护，那么其他代码怎么处理。这个维护队列的兄弟就是我们常见的浏览器。</p><p>​        浏览器会帮我们把一些耗时的操作维护起来，等到可以执行的时候就帮我们放到任务队列，然后通知我们的就是js可以执行了，你会发现这就形成了一个闭环。这就是所谓的<strong>事件循环</strong>。</p><h3 id="宏任务队列和微任务队列"><a href="#宏任务队列和微任务队列" class="headerlink" title="宏任务队列和微任务队列"></a>宏任务队列和微任务队列</h3><ul><li><p>宏任务：正常的异步任务都是宏任务，最常见的就是定时器（setInterval, setImmediate, setTimeout）、DOM监听</p></li><li><p>微任务：微任务出现比较晚，queueMicrotask、Promise和async属于微任务</p></li></ul><p>​        这个时候就有点懵逼了，两个队列，我都有待执行的代码的话，到底先执行那个？这里是有规范的，在执行任何的宏任务之前都保证微任务队列中没有待执行的任务。当然在去任务队列找任务执行之前要先保证script最顶层的代码运行完毕，比如说一些函数调用、打印…</p><h3 id="整点例子加深记忆"><a href="#整点例子加深记忆" class="headerlink" title="整点例子加深记忆"></a>整点例子加深记忆</h3><ol><li><p>第一个例子</p> <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout1&quot;</span>);</span><br><span class="line">  <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>();</span><br><span class="line">  &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">resolve</span>();</span><br><span class="line">    &#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then4&quot;</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then2&quot;</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;then1&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li><p>当js进程遇到，定时器(宏任务)，发现他并不需要等待，直接丢给宏任务队列，然后又遇到一个Promise(微任务)，他不会被加入什么队列，直接执行，然后打印出promise1，然后调用resolve，then会被加入微任务队列的。</p></li><li><p>记得上面说过的，微任务的执行时机优先于宏任务，所以打印then1。</p></li><li><p>微任务执行完毕，回过头来看宏任务，先执行setTimeout1，然后执行new Promise，直接调用resolve()，将then方法丢到微任务队列，然后发现没有其他逻辑，宏任务队列执行完毕</p></li><li><p>然后回到微任务队列，执行then方法，又遇到一个promise，执行他，然后运行到resolve方法，将then方法丢到微任务队列，然后继续往下执行，发现有个console.log()，直接执行，然后宏任务队列执行完毕</p></li><li><p>然后又来到微任务队列，调用then方法，最后输出then4</p></li><li><p>经过一通分析，我给出的结论是:promise1 —-&gt; then1 ——&gt; setTimeout1 —-&gt; then2 —-&gt; then4</p></li><li><p>看看结果</p><p><img src="https://s3.bmp.ovh/imgs/2021/11/7f699a5b18fed141.png" alt="执行结果"></p></li><li><p>结论：当js执行下宏任务的时候会先去看看为任务队列有没有东西，有东西就先执行，无论他是什么时候添加进来的，只要当前宏任务执行玩了，准备在宏任务队列里面执行下一个宏任务之前都要去瞄一眼微任务队列有没有东西。</p></li></ul></li><li><p>第二个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async1</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 start&quot;</span>);</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">async2</span>();</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async1 end&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">async2</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;async2&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script start&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;setTimeout&quot;</span>);</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="title function_">async1</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise1&quot;</span>);</span><br><span class="line">  <span class="title function_">resolve</span>();</span><br><span class="line">&#125;).<span class="title function_">then</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise2&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;script end&quot;</span>);</span><br><span class="line"><span class="comment">//执行结果：</span></span><br><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// async2</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// async1  end</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure><ul><li><p>分析代码，async1和async2都是定义函数，并不执行，所以可以直接跳过</p></li><li><p>最先输出script start</p></li><li><p>遇到定时器，丢进宏任务队列</p></li><li><p>执行async1，默认是同步代码，所以直接打印async1 start</p></li><li><p>然后调用async2，打印async2</p></li><li><p>这里有个坑，async标志的函数默认返回的就不是一个undefined了，而是一个包裹undefined的promise，所以await后面的代码其实会被作为then方法调用，then方法是要被要加微任务队列的</p></li><li><p>所以将async1 end丢入微任务队列，然后继续往下执行到new Promise</p></li><li><p>直接输出promise1，遇到resolve()，调用then方法，所以promise2会被加入微任务队列</p></li><li><p>然后继续输出script end</p></li><li><p>然后执行宏任务之前先看微任务，发现有需要执行的代码，然后依次执行，也就是async1  end  ——&gt;  promise2</p></li><li><p>然后执行完微任务，最后宏任务，也就是那个定时器，输出setTimeout</p><p>所以我们给出的结果是：script start —-&gt; async start —-&gt; async2 —-&gt; promise1 —-&gt; script end —-&gt;  async1 end —-&gt; promise2 —-&gt; setTimeout</p></li><li><p>代码运行结果：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// script start</span></span><br><span class="line"><span class="comment">// async1 start</span></span><br><span class="line"><span class="comment">// async2</span></span><br><span class="line"><span class="comment">// promise1</span></span><br><span class="line"><span class="comment">// script end</span></span><br><span class="line"><span class="comment">// async1 end</span></span><br><span class="line"><span class="comment">// promise2</span></span><br><span class="line"><span class="comment">// setTimeout</span></span><br></pre></td></tr></table></figure></li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>异步代码</title>
      <link href="/post/5c7c6e1a.html"/>
      <url>/post/5c7c6e1a.html</url>
      
        <content type="html"><![CDATA[<h2 id="JavaScript异步代码处理方案"><a href="#JavaScript异步代码处理方案" class="headerlink" title="JavaScript异步代码处理方案"></a>JavaScript异步代码处理方案</h2><h2 id="异步代码的问题"><a href="#异步代码的问题" class="headerlink" title="异步代码的问题"></a>异步代码的问题</h2><p>​        不得不说在早期的js中，处理异步代码是一个极具挑战性的问题，也是一个即为头疼的问题，不是说编写异步代码有什么难度，而是编写出维护性与阅读性并存的异步代码有难度，特别是async和await还没有出现的时代，经常在代码中出现一些回调地狱。所以今天我们就结合具体场景来看看异步代码的演进过程，了解历史才能更接近真相。</p><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><ol><li><p>首先很简单，我们就模拟实际开发中经常出现的场景，有的时候我们发送网络请求，需要拿到上一次网络请求的返回值，作为下一次发送网络请求的参数。我们将这个场景简化一下，定义一个Promise</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">request</span>(<span class="params">url</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="title function_">resolve</span>(url);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们定义一个函数，返回一个Promise，Promise内部做的事情也很简单，直接将传进来的参数丢出去</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="第一种解决方案"><a href="#第一种解决方案" class="headerlink" title="第一种解决方案"></a>第一种解决方案</h3><p>​        结合实际开发场景，出现了下面的代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1. 我们首先传入一个url</span></span><br><span class="line"><span class="comment">//2. 然后拿到返回值后在拼接一个url继续发送网络请求</span></span><br><span class="line"><span class="comment">//3. 拿到第二次网络请求的返回值后继续拼接url发送网络请求拿到返回值</span></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">request</span>(<span class="string">&quot;http://studyvue.cn&quot;</span>);</span><br><span class="line">result.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// console.log(res);</span></span><br><span class="line">  <span class="title function_">request</span>(res + <span class="string">&quot;/coderwei&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// console.log(res);</span></span><br><span class="line">    <span class="title function_">request</span>(res + <span class="string">&quot;/19&quot;</span>).<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>​        于是我们的代码演变成这个样子，也不是不能看，但是不得不说阅读性极差，作为一个合格的前端开发工程师，并不能允许自己的代码频繁出现这样的结构，如果依赖上一次网络请求的次数更多，那么最后的代码将会是惨不忍睹。不得庆幸的是人是会慢慢进步的，于是在时间的推移下，上面的代码进行的进化。</p><h3 id="第二种解决方案"><a href="#第二种解决方案" class="headerlink" title="第二种解决方案"></a>第二种解决方案</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> result = <span class="title function_">request</span>(<span class="string">&quot;http://studyvue.cn&quot;</span>);</span><br><span class="line">result</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">request</span>(res + <span class="string">&quot;/coderwei&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">request</span>(res + <span class="string">&quot;/19&quot;</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  .<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>​        首先我们需要知道Promise的返回值也是一个Promise，当我们把一个字符串作为Promise的参数传递进去的时候，会自动调用Promise.resolve方法，当然传递其他类型也会有不同的处理方式，比如说传递一个函数，会根据实际情况调用resolve或者是reject方法，这篇文章也不是讲Promise的，就不多赘述了。看向我们上面的代码，将一个Promise传递一个字符串后返回出去，我们就可以在后面继续调用then方法，这样就形成了一个链式调用，现在代码看起来阅读性就比第一种方案好多了</p><h3 id="第三种方案"><a href="#第三种方案" class="headerlink" title="第三种方案"></a>第三种方案</h3><ol><li><p>第三种方案就有点难以理解，我们需要借助Promise+生成器来完成，先写个简易版的，来看下代码的执行顺序</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//我们先定义一个生成器</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">request</span>(<span class="string">&quot;http://studyvue.cn&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">foo</span>();</span><br><span class="line">result.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><ul><li>首先我们先定义一个<strong>生成器</strong></li><li>然后调用这个<strong>生成器</strong>，拿到返回值，返回值是一个<strong>迭代器</strong>，不知道<strong>迭代器</strong>的可以看我上一篇文章，我个人觉得还是讲的很全面的</li><li>然后调用next方法拿到一个对象,这个对面长这个样子：{ value: Promise { ‘<a href="http://studyvue.cn">http://studyvue.cn</a>‘ }, done: false }</li><li>我们可以看到我们需要的东西在value属性上，并且它的值是一个Promise，于是我们拿到value的值，并且调用then方法就能拿到这次网络请求的返回值了</li></ul></li><li><p>然后在考虑下传递参数的问题，因为我们不是拿到返回值就完事了，如果是这样何必绕那么一大圈。所以我们还需要知道生成器是可以传递参数的，简单来说就是第二次调用next传递的参数能作为生成器的第一次yield 的返回值拿到，看代码</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">yield</span> <span class="title function_">request</span>(<span class="string">&quot;http://studyvue.cn&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> result2 = <span class="keyword">yield</span> <span class="title function_">request</span>(result1);</span><br><span class="line">  <span class="keyword">yield</span> <span class="title function_">request</span>(result2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> result = <span class="title function_">foo</span>();</span><br><span class="line">result.<span class="title function_">next</span>().<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">  result.<span class="title function_">next</span>(res + <span class="string">&quot;/coderwei&quot;</span>).<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">    result.<span class="title function_">next</span>(res + <span class="string">&quot;/19&quot;</span>).<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>​        这种方式看起来还是一种回调地狱，但是问题不大，我们可以看看具体处理逻辑，其实都差不多的，都是调用next方法传递参数，然后拿到value属性的值调用then方法而已，所以这里我们可以写成一个递归，当然这种代码不会写也没关系，npm仓库里就有对应的包帮我们执行我们写的生成器(co),递归的代码:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 3. 改进 ----&gt;递归</span></span><br><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">yield</span> <span class="title function_">request</span>(<span class="string">&quot;http://studyvue.cn&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> result2 = <span class="keyword">yield</span> <span class="title function_">request</span>(result1 + <span class="string">&quot;/coderwei&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> result3 = <span class="keyword">yield</span> <span class="title function_">request</span>(result2 + <span class="string">&quot;/19&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">execGenerator</span>(<span class="params">generatorFn</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> generator = <span class="title function_">generatorFn</span>();</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">exec</span>(<span class="params">res</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> result = generator.<span class="title function_">next</span>(res);</span><br><span class="line">    <span class="keyword">if</span> (result.<span class="property">done</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> result.<span class="property">value</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    result.<span class="property">value</span>.<span class="title function_">then</span>(<span class="function"><span class="params">res</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="title function_">exec</span>(res);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">exec</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">execGenerator</span>(foo);  <span class="comment">//http://studyvue.cn/coderwei/19</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="第四种方案"><a href="#第四种方案" class="headerlink" title="第四种方案"></a>第四种方案</h3><p>​        第三种方案的递归写起来还是有点麻烦的，所以我们就可以借助第三方库。这个时候就体现了一门语言有一个完善的生态和社区是多么重要。npm的仓库有一个叫co的包在处理这种代码时很出名的，他也是大神TJ的作品，同时他也是express/koa/n/commander的作者，在async和await还没出来之前，co在处理这种代码几乎是必备的。</p><ol><li><p>首先要使用第三方包肯定要先安装</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install co</span><br></pre></td></tr></table></figure></li><li><p>然后导入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const co = require(<span class="string">&#x27;co&#x27;</span>)</span><br></pre></td></tr></table></figure></li><li><p>进行使用</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span>* <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">yield</span> <span class="title function_">request</span>(<span class="string">&quot;http://studyvue.cn&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> result2 = <span class="keyword">yield</span> <span class="title function_">request</span>(result1 + <span class="string">&quot;/coderwei&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> result3 = <span class="keyword">yield</span> <span class="title function_">request</span>(result2 + <span class="string">&quot;/19&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result3);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">co</span>(foo); </span><br><span class="line"><span class="comment">//  http://studyvue.cn/coderwei/19</span></span><br></pre></td></tr></table></figure><p>这就完事了，就这么简单粗暴，co本质上就是我们在上面编写的递归函数，在node_modules文件夹中找到co，可以看到源码也就200多行，也容易看懂，而且大部分都是在做边界判断(edge case)</p></li></ol><h3 id="第五种方案-最终方案"><a href="#第五种方案-最终方案" class="headerlink" title="第五种方案(最终方案)"></a>第五种方案(最终方案)</h3><p>​        学习了那么多种方案，现在我们终于能引出最终的方案，也就是ES8(ES2017)推出的新特性:async/await</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> result1 = <span class="keyword">await</span> <span class="title function_">request</span>(<span class="string">&quot;http://studyvue.cn&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> result2 = <span class="keyword">await</span> <span class="title function_">request</span>(result1 + <span class="string">&quot;/coderwei&quot;</span>);</span><br><span class="line">  <span class="keyword">const</span> result3 = <span class="keyword">await</span> <span class="title function_">request</span>(result2 + <span class="string">&quot;/19&quot;</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(result3);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">foo</span>(); <span class="comment">// http://studyvue.cn/coderwei/19</span></span><br></pre></td></tr></table></figure><p>​        是不是很神奇，只是将*删掉，然后在函数前面加上async，然后将所有的yield换成await，结果是一模一样的。虽然这两个关键字是ES8推出的，但是目前的开发中我们都会使用babel对代码进行一个转换，所以开发的时候也可以大胆地使用。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迭代器</title>
      <link href="/post/2cf69f40.html"/>
      <url>/post/2cf69f40.html</url>
      
        <content type="html"><![CDATA[<h2 id="迭代器和可迭代对象"><a href="#迭代器和可迭代对象" class="headerlink" title="迭代器和可迭代对象"></a>迭代器和可迭代对象</h2><h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><h4 id="认识什么叫迭代器"><a href="#认识什么叫迭代器" class="headerlink" title="认识什么叫迭代器"></a>认识什么叫迭代器</h4><p>维基百科对迭代器的定义：迭代器是确使用户在容器对象上遍访的对象，使用该接口无需关心对象内部实现的细节，维基百科的解释确实很正确，但是他喜欢用概念解释概念，所以说也不好理解。我觉得用大白话来形容：<strong>就是迭代器可以帮助我们对某个数据结构进行遍历的对象</strong>，在很多语言都有，比如说java、python…</p><h4 id="JavaScript中迭代器"><a href="#JavaScript中迭代器" class="headerlink" title="JavaScript中迭代器"></a>JavaScript中迭代器</h4><ol><li><p>在JavaScript中迭代器也是一个具体的对象，不过这个对象需要符合<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Iteration_protocols"><strong>迭代器协议</strong></a>（iterator protocol）。迭代器协议定义了一系列的值产生的标准。</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/bcca5fccd8ece29d389a3684c1f42b194da14b5bf9cfa1011b658f27a0e8b87a6bd26103371ae95e266b010b3b87e38d?pictype=scale&from=30013&version=3.3.3.3&uin=916606569&fname=%E8%BF%AD%E4%BB%A3%E5%99%A8MDN%E9%94%99%E8%AF%AF%E7%9A%84%E5%9C%B0%E6%96%B9.png&size=750" alt="MDN中文文档" style="zoom:50%;" /><br>如果我们阅读英文文档会发现这个位置其实中文翻译的是有问题的，下面这副图才是正确解释</p><p><img src="https://picabstract-preview-ftn.weiyun.com/ftn_pic_abs_v3/1cf5e60501cfc3bbc5300666d3a6015bea0f147e9e51a35cf5ed53f7823061b08a6445476666b3babd3bdcc5957a4c79?pictype=scale&from=30013&version=3.3.3.3&uin=916606569&fname=%E8%BF%AD%E4%BB%A3%E5%99%A8%E8%8B%B1%E6%96%87.png&size=750" alt="MDN英文文档" style="zoom:50%;" /></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="comment">//符合迭代器协议的对象，可以通过某个标准拿到arr数组中的一个又一个的项，在js中这个标准就是一个特定的next方法</span></span><br></pre></td></tr></table></figure></li><li><p>next方法也不是随便定义的一个方法，他也有一定的要求</p><ul><li>他是一个无参数或者一个参数的函数，返回一个应当拥有以下两个属性的对象(done、value)</li><li>当done的值为false的时候，就代表迭代器可继续产出值，当迭代完毕之后就返回一个true(迭代结束的时候true可以省略)</li><li>value就是返回false之后需要给使用者返回的值，是最直观的提现，使用者可以拿到这个值进行一系列的操作，当迭代完毕的时候done的值为true，value的值是可选的，如果它存在那么就作为迭代器结束之后的默认值返回。</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> iterableArr = &#123;</span><br><span class="line">  <span class="title function_">next</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; arr.<span class="property">length</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: arr[index++] &#125;;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span>, <span class="attr">value</span>: <span class="literal">undefined</span> &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterableArr.<span class="title function_">next</span>());  <span class="comment">//&#123; done: false, value: 1 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterableArr.<span class="title function_">next</span>());  <span class="comment">//&#123; done: false, value: 2 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterableArr.<span class="title function_">next</span>());  <span class="comment">//&#123; done: false, value: 3 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterableArr.<span class="title function_">next</span>());  <span class="comment">//&#123; done: false, value: 4 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterableArr.<span class="title function_">next</span>());  <span class="comment">//&#123; done: false, value: 5 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterableArr.<span class="title function_">next</span>());  <span class="comment">//&#123; done: true, value: undefined &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(iterableArr.<span class="title function_">next</span>());  <span class="comment">//&#123; done: true, value: undefined &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//这样我们就实现了一个简易的迭代器</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="可迭代对象"><a href="#可迭代对象" class="headerlink" title="可迭代对象"></a>可迭代对象</h3><h4 id="认识什么叫可迭代对象"><a href="#认识什么叫可迭代对象" class="headerlink" title="认识什么叫可迭代对象"></a>认识什么叫可迭代对象</h4><p>​        可迭代对象和迭代器完全是两个概念，不能混淆了，可迭代对象需要实现（adorably protocol协议）</p><p>并且返回一个迭代器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> iterableObj = &#123;</span><br><span class="line">  <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="title class_">Symbol</span>.<span class="property">iterator</span>]() &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">      <span class="attr">next</span>: <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (index &lt; <span class="variable language_">this</span>.<span class="property">arr</span>.<span class="property">length</span>) &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">false</span>, <span class="attr">value</span>: <span class="variable language_">this</span>.<span class="property">arr</span>[index++] &#125;;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">return</span> &#123; <span class="attr">done</span>: <span class="literal">true</span> &#125;;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> iterableObj) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item); <span class="comment">//1,2,3,4,5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代器这种代码，通过调用next去获取数组的每一项，我们在开发中是很少写的，但是这种for..of的代码在开发中是很常见的，for..of可以看做这种语法的语法糖。</p><h4 id="可迭代对象的应用"><a href="#可迭代对象的应用" class="headerlink" title="可迭代对象的应用"></a>可迭代对象的应用</h4><ol><li><p>可以应用于for..of遍历</p></li><li><p>也可以引用到展开运算符中</p><ul><li><p>如果是一个对象，那么也是可以的，那么就有一个问题，for..of遍历对象的时候是不可以的，会报错的，例子:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;coderwei&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">19</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> newObj = &#123; ...obj &#125;; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(newObj);  <span class="comment">//&#123;name:&#x27;coderwei&#x27;,age:19&#125;</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> item <span class="keyword">of</span> <span class="title class_">Obj</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(item);  <span class="comment">//报错</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//展开运算符用在一个对象上原理不是利用可迭代对象，这时ES9提出来的，对对象使用的时候会做特殊的处理，而且展开运算符只能将对象展开到另一个对象。如果展开到数组里依旧会报错：xxx is not iterable</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>解构</p><ul><li><p>当我们使用解构赋值的时候，本质上也是利用可迭代对象的特性，当前同样要区分解构对象和数组</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//解构数组</span></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> [x ,y ,z ] = arr</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(x,y,z) <span class="comment">//1,2,3</span></span><br><span class="line"><span class="keyword">const</span> [x ,z ,y] = arr</span><br><span class="line"> <span class="variable language_">console</span>.<span class="title function_">log</span>(x,y,z) <span class="comment">// 1,3,2</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//解构对象</span></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">name</span>:<span class="string">&#x27;coderwei&#x27;</span>,<span class="attr">age</span>:<span class="number">19</span>&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> &#123;name,age&#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">age</span>) <span class="comment">//&#x27;coderwei&#x27;,19</span></span><br><span class="line"><span class="keyword">const</span> &#123;obj,name&#125; = obj</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name.<span class="property">age</span>) <span class="comment">//&#x27;coderwei&#x27;,19</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//我们可以发现当我们解构对象的时候，跟定义变量的顺序是无关的，而解构数组则是有关的，也证明了解构数组只是调用迭代器的next方法拿到一个个的value，然后将它赋值给定义的变量</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><h2 id="封装一个创建迭代器的函数"><a href="#封装一个创建迭代器的函数" class="headerlink" title="封装一个创建迭代器的函数"></a>封装一个创建迭代器的函数</h2><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createIterator</span>(<span class="params">arr</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line"><span class="attr">next</span>:<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(index&lt;arr.<span class="property">length</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">false</span>,<span class="attr">value</span>:arr[index++]&#125;</span><br><span class="line">       &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> &#123;<span class="attr">done</span>:<span class="literal">true</span>,<span class="attr">value</span>:<span class="literal">undefined</span>&#125;</span><br><span class="line">    &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="keyword">let</span> itor = <span class="title function_">createIterator</span>(arr);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(itor.<span class="title function_">next</span>());  <span class="comment">//&#123; done: false, value: 1 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(itor.<span class="title function_">next</span>());  <span class="comment">//&#123; done: false, value: 2 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(itor.<span class="title function_">next</span>());  <span class="comment">//&#123; done: false, value: 3 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(itor.<span class="title function_">next</span>());  <span class="comment">//&#123; done: false, value: 4 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(itor.<span class="title function_">next</span>());  <span class="comment">//&#123; done: false, value: 5 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(itor.<span class="title function_">next</span>());  <span class="comment">//&#123; done: true, value: undefined &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(itor.<span class="title function_">next</span>());  <span class="comment">//&#123; done: true, value: undefined &#125;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>寄生组合式继承</title>
      <link href="/post/e284c1d7.html"/>
      <url>/post/e284c1d7.html</url>
      
        <content type="html"><![CDATA[<h1 id="JS的寄生组合式继承"><a href="#JS的寄生组合式继承" class="headerlink" title="JS的寄生组合式继承"></a>JS的寄生组合式继承</h1><h3 id="什么叫继承"><a href="#什么叫继承" class="headerlink" title="什么叫继承"></a>什么叫继承</h3><ol><li>在很多语言中，都有继承的概念，继承他可以让我们的代码更加简化，没有那么亢余，在实际开发过程中，我们肯定会遇到多个对象拥有共同属性的情况，这个时候我们是每个对象都写一遍重复的代码呢，还是考虑将其抽离出去，给他们一个共同的父类呢？当我们是开发中习惯了这种思维，我相信整个代码的可阅读性和可拓展性都是不可比的。</li></ol><h3 id="如何在js中实现继承"><a href="#如何在js中实现继承" class="headerlink" title="如何在js中实现继承"></a>如何在js中实现继承</h3><p>首先给出个概念，ES6提出的class，他是一个全新的概念吗？并不是，他只是一种语法糖。一种基于寄生组合式继承的语法糖，下面就详细的看看这到底是一个什么东西？</p><ol><li><p>首先我们先定义一个普通的构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里有个细节，或者是是一种规范，通常定义的构造函数我们会以大写字母开头，以便和普通的函数加以区分，这时社区的一种不谋而合规范，即便不遵守从代码层面来说也没问题</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">People</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后我们给这个构造函数的原型上定义一些方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">People</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eating</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;吃就完事了&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">People</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sleeping</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;睡就完事了&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>我们再次定义一个构造函数</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age, number, height, sex</span>) &#123;</span><br><span class="line">  <span class="title class_">People</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">number</span> = number;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">height</span> = height;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//这里我们用People.call，让Student构造函数能够执行Person的方法，因为name和age我们不想重新再次复写，</span></span><br></pre></td></tr></table></figure></li><li><p>给Student的原型上定义一个自己的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">wan</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出去玩&quot;</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p>然后我们实例化一个Student对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;dw&quot;</span>, <span class="number">18</span>, <span class="number">100</span>, <span class="number">1.98</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//s1 ----&gt;Student &#123; name: &#x27;dw&#x27;, age: 18, number: 100, height: 1.98, sex: &#x27;男&#x27; &#125;</span></span><br></pre></td></tr></table></figure></li><li><p>好，准备工作我们就做完了，我们做了那么多铺垫，我们的目的是什么呢？我们需要通过s1访问到Person定义的两个方法，这样的话我们就将Student和Person联系在一起了，从某种意义上来说就是实现了继承</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(<span class="title class_">People</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"> <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(<span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">   <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">   <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">   <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">   <span class="attr">value</span>: <span class="title class_">Student</span>,</span><br><span class="line"> &#125;);</span><br><span class="line"><span class="comment">//Object.create方法会返回一个对象，并且将传递进去的对象的原型对象作为返回对象的隐式原型   举个例子</span></span><br><span class="line"><span class="comment">//example</span></span><br><span class="line"><span class="keyword">let</span> test = &#123;<span class="attr">name</span>:<span class="string">&#x27;codeywei&#x27;</span>,<span class="attr">age</span>:<span class="number">18</span>&#125;</span><br><span class="line"><span class="keyword">const</span> obj = <span class="title class_">Object</span>.<span class="title function_">create</span>(test)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property">__proto__</span>)  <span class="comment">//&#123; name: &#x27;coderwei&#x27;, age: 18 &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj.<span class="property"><span class="keyword">prototype</span></span> === test.<span class="property"><span class="keyword">prototype</span></span>);  <span class="comment">//true</span></span><br></pre></td></tr></table></figure></li><li><p>现在我们就成功的将原本毫无关系的Person、Student联系到一起，并且实例化的Student可以访问到Person上的方法</p></li><li><p>粗略的画了一副s1、Person、Student原型图</p><p><img src="data:image/png;base64,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" alt="原型图"></p></li></ol><h3 id="提示"><a href="#提示" class="headerlink" title="提示"></a>提示</h3><ol><li>当然这种方法是有弊端的，比如说代码顺序，如果在Object.create之前创建实例对象s1或者是给Student的原型上定义方法，在后续我们是访问不到的</li><li>为什么呢？其实思考一下也能发现，js是单线程语言的解释性语言，解释一行执行一行，当创建实例s1的时候还没有将他们联系到一起，那么这个对象已经创建出来了，后续在通过create函数将Person和Student联系到一起的时候，s1对象的隐式原型依然不是Person.prototype的</li><li>至于为什么访问不到方法，先在Student.prototype添加一个方法，后续创建一个新的对象将其覆盖，之前的方法自然也不会存在。</li></ol><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>我有个习惯，写完代码会对代码进行审视，最起码站在我先在的知识面，对代码进行审视，何处优化？怎么优化？这就是一个进步的过程，没有绝对完美的代码，只有不断趋近于完美的代码，所以最后，这个代码的Object.create方法我觉得可以进行封装，不可能每次对两个构造函数进行继承处理的时候都复写一遍这样的代码，逻辑还是一模一样的，所以最后的代码我就直接贴在下面了</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对寄生组合继式承封装</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">myextend</span>(<span class="params">newObj, oldObj</span>) &#123;</span><br><span class="line">  newObj.<span class="property"><span class="keyword">prototype</span></span> = <span class="title class_">Object</span>.<span class="title function_">create</span>(oldObj);</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(newObj.<span class="property"><span class="keyword">prototype</span></span>, <span class="string">&quot;constructor&quot;</span>, &#123;</span><br><span class="line">    <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">writable</span>: <span class="literal">true</span>,</span><br><span class="line">    <span class="attr">value</span>: newObj,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">People</span>(<span class="params">name, age</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">People</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">eating</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;吃就完事了&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="title class_">People</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sleeping</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;谁就完事了&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Student</span>(<span class="params">name, age, number, height, sex</span>) &#123;</span><br><span class="line">  <span class="title class_">People</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name, age);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">number</span> = number;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">height</span> = height;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sex</span> = sex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">myextend</span>(<span class="title class_">Student</span>, <span class="title class_">People</span>.<span class="property"><span class="keyword">prototype</span></span>);</span><br><span class="line"><span class="title class_">Student</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">wan</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;出去玩&quot;</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="title class_">Student</span>(<span class="string">&quot;dw&quot;</span>, <span class="number">18</span>, <span class="number">100</span>, <span class="number">1.98</span>, <span class="string">&quot;男&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1);</span><br><span class="line">s1.<span class="title function_">wan</span>(); <span class="comment">//出去玩</span></span><br><span class="line">s1.<span class="title function_">eating</span>(); <span class="comment">//吃就完事了</span></span><br></pre></td></tr></table></figure><p>最后的最后，恭喜EDG，成功拿下GEN，我们六号决赛见。</p>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>响应式原理</title>
      <link href="/post/c8b44329.html"/>
      <url>/post/c8b44329.html</url>
      
        <content type="html"><![CDATA[<h1 id="响应式原理"><a href="#响应式原理" class="headerlink" title="响应式原理"></a>响应式原理</h1><p> 提到Vue难免离不开响应式原理，在学习响应式原理之前，首先需要搞明白一个概念：何谓响应式？Vue官方文档响应式的解释是：响应性是一种允许我们以声明式的方式去适应变化的编程范例，乍一看还挺难以理解，用通俗点的大白话来说：响应式就是在数据发生变化的时候执行某个或者某些回调，使页面发生更新，也就是数据驱动页面的更新。今天我们就动手使用原生JS实现Vue的响应式原理</p><h3 id="如何实现响应式"><a href="#如何实现响应式" class="headerlink" title="如何实现响应式"></a>如何实现响应式</h3><ol><li><p>首先我们需要准备一个对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> info = &#123;</span><br><span class="line">    <span class="attr">name</span>:<span class="string">&#x27;coderwei&#x27;</span>,</span><br><span class="line">    <span class="attr">age</span>:<span class="number">18</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>首先我们可以先定义一个副作用函数，说白了就是我们需要告诉JS，当对象的属性发生变化后，你要做什么</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//副作用函数:要求传递进来一个函数，函数内部直接执行</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchFn</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>我们需要利用Proxy拦截info对象的get和set方法想要实现响应式</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">const</span> infoProxy = <span class="keyword">new</span> <span class="title class_">Proxy</span>(info, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params">target, key, recesver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;获取info对象的值&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, recesver);</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">target, key, newValue, recesver</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;设置info对象的值&quot;</span>);</span><br><span class="line">    <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, recesver);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li></ol><ol><li><p>然后我们在写一点测试数据</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// name发生变化需要执行的逻辑</span></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( infoProxy.<span class="property">name</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// age发生变化需要执行的逻辑</span></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>( infoProxy.<span class="property">age</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></li><li><p>运行代码，我们可以看到当设置对象某个属性的值的时候会来到set方法，当我们获取某个属性的值的时候会来到get方法说明我们劫持成功了<img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA2cAAAEGCAIAAABuHnrkAAAACXBIWXMAABJ0AAASdAHeZh94AAAAEXRFWHRTb2Z0d2FyZQBTbmlwYXN0ZV0Xzt0AACAASURBVHic7d19cBTngefxh4Rsjbcut5oRWku2s2ZehAObpApZGrCc3QiIERLO3jlSBAayyUrI64Ag3AYDi8s2NmUFg5MlRtiOBYoTixdjiH17tpDwIbRVQYGREFeJAwHNaJR1bCkra0bEyTJbTsL98UgPrZ6XbmleQd9PUdT0y3Q/PfNMz0/P83TPtGvXrgkAAAAgpo+luwAAAAC4AZAaAQAAYIzUCAAAAGOkRgAAABgjNQIAAMAYqREAAADGSI0AAAAwNv23v/t9ussAAACATEdbIwAAAIyRGgEAAGCM1AgAAABjpEYAAAAYIzUCAADA2PR0FyCCnp5zx996KxQKGa6Zm5dXs7rWYrGY2eyly767ZjnjLh0AAMBUlImp8f/19MyeM6eg4G7DNffvaxwcGJhpt6egVAAAAFOZ2dQ4MhI839NjuFpWlnX2nDkmG/9ib4csCAAAkDnMpsYDzc1CiFuM4uDVUKin51zN6tp4ywUAAIBMYjY1Dg4M1KyuNWz/6/f79+9rjLtUAAAAyCyZOK4xwz25vX54OKAmy8tKl5Te19r2ttfrq1v7cBoLlkbHW1p27XxGTbZ3/FsKdtrn862uqU7NvsJ5urqbDxyWj7OzbU88tjUtxUiZQCC47amnZ+W7dJX8ye31ZUsWu4sKU18kn6/ve3uef273synbo+6zv+3xR2026yS2EP4yTk3yQyRPoREXrVq5PC1VK8Ua9r44HAjEfw7RfiISss3WtrdbjrdNop6nQMrOwPJVvVGq4sFDR4QQKx6s0s5cv2Hj/Hlu3Uwd86fTTEmNIyPBUyfbA8GAEGJwYCA4MuL39wkhbrvttrLypekunV5GVSBPV/fx1hNpTC0LS75QVl6u0ltXl6ery1NU5E5XeVKgte3ts54u9QGTH9Sp4HKv19PVPdHKn8ZkmXDqs9/a9va2p56e0Bdqa9vb2bab/w+MiTrr6QpPjcdbT2Rn29JSnhQLBIKXe73Z2Tafr8/pdCRqs5P+s0T7aV1Sel/4W5MJUnkGdjodakfyj+fMjNExxPmntS5jJDg1ZlmzFixcNIknXvjFhZ6ec2oyFAqNBINCiH6/f/bsOVwZk7F27XzmH6qrv/r3X1Nzbu68KJ31dJUtWawmY/8NdzMpLyttPnD45sh/cVpSep/X6/N0dZv/Wg0EgjbblEhC5sloqPtTxOfrS1+JUs3T1T1/nttms571dCcwNd7cpuwZOBNMPjWOjASzsvRxOyvLunDRZFJjKBSyWCx5eXm6+X6/f5LlS6uDh46cOeuRj1XMX79h4zfXrfnenufFWIu6bP8XQuhaj1VHmOrJkq3H6ulqsw17X7zc65UbVyuv37BRrmPYKB2nPp/veEtLjD5ibc/1I5s2l5WXy8cLS76wb3/T6ppqOblvf5PD6VSL5ANtGN2185njLS3hK2u98qMf/qCpST5Odrd1ts0WCAQjLpLvlHys7YiU7776VlB/0Kvuj+YDh9X66m0Vmm7Q8FqhXTM1veTuokKv13fw0JFo9UpXSPVqNB843HzgsKzAqrlO9jGpD4i2kUPVYaH5BMlxIDab7cxZT3lZab7rejWQm0p2hY9GtkDIx6q/VffODgcC8pU5c9YjX4FoVUV3mEIIr9fncjnluUI+V70+2mYP9eJrK0PD3hddLqfX65P1RNcdrLajnqLt+NPW2OSZ5y7yeMalxuOtJ+a5i856urSrGZ4V5buvPhG6HiHDGjV/nvvMWY/29WzY+6LNZkt2jTrr6Vq1YrnVat321NPafck3LhAIyq+S8JNJ88HD8gWJ2MWvGzQVfkrRvtG6Cqk+rUIIba+l+sLS7TR2HUuGGGfgaBVYW3j1ITJ5TpZr9np9cgvywy4rXuorzCTIN0i9KeqzUF5WKvO3+qRoT0rRMsbkU2Pn6dPne3rsdofd4bDb7blhgW+i8vLyqsMuvn7s0RuvN+fgoSOBQEC+4q1tbz+5vV6dwdUn8Mnt9es3bCwvK31u97PyK2eeu1BW3ye3189zF8k3uGHvi9pv6OOtJ9QbKefXrX1Y13r85PZ6bSdaUo/00qVLKgiGe+VHP+zydKkAJ+OgWl8NSTze0rL7X/7luYYGIcT6urpndu2SrZUqJq6vqytyF8mV5VjG8OD4yo9+ODg4qDa4vq5ObjBJypYs/t6e58NHssoTljqPNOx9sWHvi2a6ijyebnVqbtj7ohj7xHq6uuXMiLXi4KEjNptN1bREHmF08thVddWKWMjndj+rjYPz57m93j752OvtE0LIjrlAIDg8HHAXFcqPg7YOr9+wUb04l3u98lMjNC1SgUAwLWPghgMBt220wOrrZ/2GjTabVZVE+85qhxzFriraw2xte/tyr9flcj63+1n5LBW1Dx46cvDQq/JZnq5u9SLrzhstx9u+uW6NCvHuokK5U3kKku+XrD/aHC9XTkFnnLuosOV4WyAQlDuSPbZ1ax/WpkbDs6J8F86c9cgjlQciXw3zNarX61WNx7IY2x5/NKnH7vP1DQ8HZM3Jzrbp2lxbjretWrlcHumT2+u1R63eGnl02ioXLuIpRdVM+Ua7nE7ZFav9tGobfQ8eOtLr9WobQYQQKohEq2NJEvsMHF6BZWSU8wOBoNfnM9yF9pMrLSm9z11UqO2hlm9ZKitM/J7cXq/+uj546Ih2oLYYnzHkGSk8Y0z+FwXtDkcoFLp48ULLW2/ubdjz9PanDjY3/7Szc3BgII4jujE0Hzi8fsNG+U/XmSL/NFRVeUnpfcPDAbXOqpXL5YN57iIx9pGz2azZ2bbhQEAI4enqzrbZ1EexbMli1WYphFjx4DL5wO0u7PV6I5ZteDiQPdYLloIhKbm5uRHnB4PBHzQ1Pbl9u5rzzK5dKgjKSflg/j33vPPOz4PBoBDinXd+nm3LlvNlvuzq8gghVKOjw+n8h+rq06d/Er6vRzZtVk98552f95k4L0yaPL0OBwLrN2zUDqk53npi1crl6nS54sFll3u90f4m1lLvrM/XJ78y5aQ8+UarFYFAQO0rZcOPnE7H/Hnu5oOHdfNjV13F5XKoqivb0nq9PiGE1+eble8SQrS2vT1/nlt9BS4pvU+emuVkdrYt/Ei3PfV0eVlpiiOjfN/dRYWtbW+Xl5WqDF1eVurxdKvV1DurE7uq6A5TTcpjlA2QQgiXyyHPG3KRegXc7sJA4PqXwfx5blk8p9ORnW2TX5mtbW/PynepvcgHx1tPyBYmufKsfJd65ZPHZrPOn+dWf/bIHlvtCmbOijabdVa+a1a+Sx6py+kUQsjX03yNmucu8npHzxuyQiY7Mfd6fepgZZurdqm22KtWLNcetao8NptVV+V0Ip5ShGbgo6wV8gwcjfxeW7f2G9oCaGN9xDqWPDHOwBErsAy1cn7shK1E++Rqpb7CxEm+Gupvj/BmUW3GGA4ERCSTb2u028e1NMgEefHiBSHE7NlzVqxaNektZ74YrRrys6ftDdFSeU4mRe18eYKTf69Ee7qqkdk2m+5PBKW8rPR7e55P2UWag4ODEecHA4HPfOazVuv1j5DLlf/OOz9XkyodynWCgYDVan1k0+bVNdVl5eUqAn4w9EGRu0i75U/Pnt1x6pRuX0LTtZ0y8m+v9Rs29nq98vHwcMClaQSV73IwGDQ8lagVtN8iSrRaIf/gVn9Dp8yKB6vWb9jY2va2NtnErrqKy+kcHg4EAsFgMDgr35Xvch5vPSFK7/N6+1wu+U0fcLvHfbjyXa7rcSpsXOCT2+tT0COmyKY+IcSsfJd80wOBwJmzHtX5JRepx9He+thVRXeY2snsbFu084DuqtKIZVCnGq/Xp3udZalU/5TkcqXiV1jnuQu/t+d5+R2m/YKXTJ4VtWNG5Uz5epqvUdpWT4+nO/z1STjZPR2+d+1RSPI8qZZmjz/YaF/wIsopRdLeE2A4EIgxGiEYDGornhj7IGvLoB7H6D5OrIhn4PAK7PP1ZWfbJjrWwkz+S32FiVMgEMx3ubRzdNecmckYk0+NFoslNy9P17JosVgWLFxUfO+9k97sTSDOEWZxjs2SV7017H1R2/2UJDNyZrz77+8mcINl5eVl5eW7dj6zsOQL2nGQhj7zmc8mtUs6BtmnM4kriyckYq2Qf3DLHrcU38xFDvrR1S4zVVe2CXl9vkAg6HYXOp0OOWim1+vVtmRMiNfrE6lKjRH/YsyEmyrIO62oXsjjrScmt520XB+qbRZS7YVaqRmxqiqnSzi17XNJIrundSkn9vVV0d6a8L+mDHetHWH85Pb6CT09o+jOwOEVOHkXV6W4wmSIyfdQCyHs4y9tzrJa165bN8Ujo9VqlU0pk3u6zWaN1vU8IXVrH161crm2/SMZiorc77zzc22/s2K12VS/s+T19n7mM581s9lHNm1+ZtcueRnNjJwZXeMHxf/y4kVdt3j4vlJMnbJ1XTNyrJ5sJFCDEKRof8ZFrACxa8WS0vu2Pf7o5V5vKq88dRcVzsp3afuGzFddl8vp9fZ5vT7Z2KbiwliPm02Od1R6vd4YOeaJx7YOBwJy5FZahBfYjBhVZXIu916P3WbOPxGLnYK+xWjc7sLjrSeOt54Ib7CJ86w4oRrldhd6PN1eX9T2uQQ66+meP8/93O5n1T95dYJaQfs+en0+bbOQ9mTi9fbFuDY/4qsnGyDVnzrRTkdK+PearjzpFe0MLEX7UjZ5To4tlRUmfrrKIE87E91IfKnRMe4vwpFgsK9vCt0xISL5x8eevS+oORO6lZS7qHB4OKCeEggEDa9y0LUka3eXgk/1vv1N2gucxdj9Gq1W6z9UVz/x2GNq/uZHHvnq1/4+9tZe+dEP1WMZMeWVMWp+n8/3g6am+7/0d9pnWa3WsvJy7b6020kGbUaRw4ZkACpbsrj5wGF1ejp46FV5Tw0hRL7LpZp/YlQJeR5XK3i6ugOBYLRaodtOPJljElY8uOzMWY+qezGqrq7HKt/l7PV6h8cGZbpczuOtJ1S/yZLS+86c9ahhZ3IjsVvynnhs6+Veb7rumjnPXagtsKer20x8j1FVJk1+XwYCQTN/LkZ8nee5i8aXKnUvqaw/ItJ7PYmzotaEapS7qPByr9fj6Z6X/N7GM2c9ur3II1X158xZj3rcfOCw9l4zaiiCz9d35qwnRvNkxFOKEEKlB927HLF/WY491X6v6cqTYtHOwBErsK7wgUBQVgaT52QtNfJBzUllhYmfrGDq43Pw0KtmnqXLGHHdr1ENbcyyWisqKg80v/L6sWNCiIKCu+PZbOZTY5vE+BsiSHVrH5YdxHJSXQFj0nO7n12/YaMa+Gx4TZYcfaz6KM+c9YTf9Cd5HE5ne8e/ra+rU3fYUaMS5SUsarihujg6hh80NYXfPee5hob1dXVq/rHX3wiPR49s2iz7tdW+4jwuQ9pRVqpPZLSLZOwmLNputRUPVskL54UQq1Yuj9F28sRjW9WaarRDxFoRCARUMb65bk2KOxblMHxtQIlWdd3uwuYDh+V4NafT4XQ6hocD6pKOfJez5Xhb2RKH2uy2xx/d9tTT8iNmcryHfIoa3pRKTqdD3oNjQgWOUVUmR44ZaD5wODvbtmrlcsMeat3rLFtKZPjQliqeIk2UqhLhJnpW1JpojZo/z93r9Sb7lkPym1u3F9nooG7cWF5Wqr29jjbprlq53PxnP/yUsqT0vrOeroinI+2nVbsRedMG7fdaekdlRDwDR6vAusLL+mP+nKw1f55bDipQX6+pqTDmaTNAeG2XnwV53v7mujXDgYDh8AZdxph25cPfmSnHd57dZbFYLBaLnKwZu0XO3oY96ieqBwcG9u9rDIVCD1RUTDQ4tp882e/vi3jnnRi/fx17qc6ly767ZqViZDcA4Aalu7ldBhZDd6NBpFeGVJjJWb9h40SHMptta6xZvbrnXE/4fLvdbrfbZW7LzcurWV27f1/j68eOORyO8HuAxxYcGTnVfnJCTwEAIFFkd6eZu64A4gavMA17X5zE3YLMpsZoP/pSUHB3lqa7UAbH9wfen2hkFEKMBIPtJyOkxoGBgWsT3RYAAKapH/hJ/WAP3Ihu0Aqj7dmf3MAYsz3Uydbv9x9ofiUUCk3oWVlW69q6darfPDZ6qAEAACYtU1IjAAAAMllcd94BAADAFEFqBAAAgDFSIwAAAIyRGgEAAGAsrt+Gwc1n9rYpenXUxW3/Ld1FAAAgo9HWCAAAAGPTL132pbsMyCi3prsA6cEHAQCA2LhfIwAAAIzRQw0AAABjXA2DBPjDRx+luwgAACC5SI1IjA9/eyXdRQAAAElEakTC3HnnnekuAgAASBbGNQIAAMDYFEqNN+6tVTKn5Jcu+zKnMAAAIJWmUGoEAADApBmMa2w/eXLaNHHt2ujkyEgwdDWUm5cnhNDOD+dwOGba7Qkp4uDAwMDAQCgUys3LsydomwAAAJgQ46th+vr61OORkZHQ1atXQ1djP6Xf73c4HHGWLBQKnWo/2Xn6tG7+TLu9orIyK8sa5/aniMGBAb/fHwpdHQmOZFmzLJZb7Ha7zP0AAADmmbqGumZ1rXzQfvJkv7+vemwymsce3RpnsQYHBg4caB4JBsMX9fv9e/fs+XJl5ezZc+Lcy82tp+fcqfb2iK9hltW6cOGiuQUFqS8VAAC4QWXinXdGRoL79zWGQiEhxOzZc8rvXypbFkdGgj3nen7aeToUCh1sbq5ZXZuoTvCbTCgU2r+vcXBgQM3Jzcu7xWK5GgrJmSPB4I+PHe3pObdy1VctFkv6SgoAAG4Yk0+NIyPBJHUTHzt6VEZGIURwJGix3CIfZ2VZFy5aNGfOHJkpDzS/8q1HNiU89Hi6uo+3nnjisXibS3XaT56MtmjhokUJ3NHgwIDK3EKI3Ly8iopK1SU9ODBw7NhRmR37/f7v7NpZs7o2eR3Ww8OBb21+VDvnnzf9kxDi2zu/W1v9tXuL51+63Pvtnd99ed8LSSoAAABIlMmnxh8fPWq12sqWLk1sbuvpOdfv9wshLBZLKBSSGahmda3aS25e3spVX5XBqOWtN79cUZnAvSfPzJkzm1/50Ufjf3nvE3/2Z48/sS2BewmFQgcONKvImGW1ypeu8/Tp//qvkMVyyz3FxTWra/c27JE913L9tXXrktri+J1nns7OtmnnRIyJpzvPvPGvb+3asT15JQEAAJMWVw91T8+5Cxd+kdghhrIZLMtqXVu3TnazhgfHmXa73W73+/0Dmk7YhGjY++LlXq8QYv2GjbPyXXVrHxZCtLa93XK8Ta5QXla6pPQ++Xj9ho3fXLem+eDh4eGAblE4h9Ppnjfv9E9+op15/5e+lNjyt7z1pnYgY/nSpRaLpWlfo9/vl3MuXPhFzera8qVLDzY3yzkjweANFL4BAEC6xDuuUQ4xnD17zpcrKxPSXiVT4+zZsy0WS83q2ujB0eH3+wcTnRrr1j6s66E+eOhIr9f73O5n5eT6DRuFECodfm/P89sef9RmswYCwW1PPW2zWd1FhdE2/oWSBZcvXRoaGpKTebfdVlBwdwILPzISPN/To51jtztGRoIqMgoh+v3+kZGg3T7uCvfzPT0LFy1K5WXpX1/9jX/e9E93zcpXc555dvfFX16Si2Z/+q7NGzcIIU53nmls+qFcQa3/zLO7P31X/k9Onxn64APdRgAAQPIk5i7fFy9e+M6unSMjES7XnSj/aPf0LUIIGRzlqDvdcL2820aH4vVrIlHCBQLBM2c969Z+Q81ZtXL5WU+XdtJmswohbDZreVmpx9MdY2u33HLL5//2b9VkefnSxJZWe48kyWKxhK6GdDNDV0Ph+T78uSm2eeOG2uqv5cyY8fK+F7SR8eV9L7y874V/3vRP3975XdmmK4R4/X+/ubr671/e9wKREQCAlElMasyyWleu+mpCGqt0V2ZEC44D7w9EXD+xgsFgdrZN5kLJ5XSq7CKEyLZdH65ns1mHAwERU0HB3bI3/7Of+1zCLwAvKLg7yzruLej3+3Pz8rQvkcViyc3L00Xt3Ly8xLZ66nxr86NfX/2Nr6/+xiNbHjP/rDf+9S156YwQ4q5Z+bM/fddPOn8qJ//m88XkRQAAUiwBd965p7h44aIvJupyiry8vMGBgYsXL6griyN2Vfv9fUKILKs1o24cow2R0SxYuPDixQuLS0uTUYCVK1ftbdijJjtPn55pt69ctarlzbcGBgesWVnlS++X87XPqkjyoMbwq2HMGPrgg2/v/K52zqfvGk2KMya+NQAAEKe4UmOW1VpRUZnYNrPc3NFmxX6/X205PDjKEY15ucn9jROr1To8HAgEgqq50evzaQPQcCDgdI6OEfR6+2wmUmPebbctWJisQYS5eXkPVFS8fuyYnLx48cJPOzvvKS5esWqVWqf95MmLFy+oyQcqKjL2p2ImFzcBAEAyTL6H+p577/3WxkcS381692g364HmV7QXu+i6quXMxN7pUMq22VQftM1mnT/PvWfv9dvENB84XLZksXZSPvD5+s6c9cS4hlorGcVWCgrufqCiQk22vPXm/n2Np9pP+v3+U+0n5WO5yGKxPFBRkdS+6XjkzJjxy0uX010KAAAwavJtjUn6QT+LxVJRUSnHL+7f11h87733FN+ruqHnzJmjImNZ+dJkNJI5nY7sbJu6886KB6sOHjoiL50WQqxauVx7lfSqlcvVom+uW6MdAZlGBQV335Z3W8tbb8pLi/r9/n6/X4hxtxm32+1fzrCf854xI3vogw/U5Ofvnd/Y9MNP3zVLNjfuf/mVmq9/NW2FAwBgysvEXxScabfLbtZQKNR+8mT7yZNZVmvo6lV1AbUQ4p7i4uJ7701SAXQ/DLPiwaoVD1ZFXDPbZlM35ckouXl51atrBwcGenrODQ4MqJvv2O12ee1LBvZK3zUrP2fGDHXnnf/xpaVCCPXTMn/z+eK0lg4AgKlu2pUPfxdjcfvJk35/n8PhuHZNTJsm/H19wZGRuXMLpk0T165Ffdap9pPx/0i09rfvtCwWy+TuK37psu+uWc54iqQj7/KtxjUmT8JLPmmXLvuEEOGF+cNHH3342yt33nlnOgoFAABSwVRbo7qZ3+9/97s//elP8vrlGBIy2DE3L29t3bp+v//9998fHBwIXQ3l5uU5HI7cvLyMum4aAABgKjBIjQsXLRIiiZduGJpptyf8gptEycy+aQAAgGQw6KEGzKCHGgCAm15ifhsGAAAAN7dMvIYaN6hf/epX6S4CAABIFlIjEuOT//0v0l0EAACQRKRGJMD0T3wi3UUAAADJxbhGAAAAGCM1AgAAwNh0+WsfAAAAQAzTrsX4ZUAAAABACEEPNQAAAMwgNQIAAMAYqREAAADGSI0AAAAwRmoEAACAsdSlRrsjP+LjG1qMA5noMerWN3z6RNcHAACIR3J/UTBGstE+9vf1Rlxfu+jGIg/kpjkcAACA1N2v0e7I16bDaPlJLZIPMiF46cqgLUDEAzE/M8bSGDsV0V+caOsDAADEKbltjVraHGM+08hsFKMxUgjRsyO/4qWaY31bCkwXZuhorXtThxBCiJIdnY3Lcg3KoB6HNyLKx7oSRiynmhkxIGqX6kJktHRomF8BAAASJempUbWKhUecaEEn6UP0une4N4kdnb2xw2IMMRpNox2sdjL2Bg3zX7SO/mipFAAAIH5JT40x0mG0RaqH2uQuCrb0+rdMoEhD/T5Rsnih6cio6zQ3+ZQYk7EZRkZd33Tsrm0AAICESE9boxJnq5imo3lcD/XQ0Vq3d43H9fzo0oeO+LfMNdrY+XpHVePo43FbM2w+1ElIx7H5V4yYCAAAUiDp11BH65w131qmQlt4kMqpbPRXCtG9w14Vtu+XqtwPHfH3NYrB16qLq+q/2Lu1cOjV6uItHXJxh9uxVQgVKM/XO6q8Ozv9lTlChk7HjhjBMUYO1h1F+LhMk53yZnah1oy9KQAAgPglNzXq+prNXEMd/qxJKqn3yPbF3JLSEtHWPyQKc5Y19S6TobBlsafpKzlq5e62RlFzrHJ0Rk7lmtpNVa3dWwoKx23STIzTHaw278Z4euzLfUzuEQAAIHlS10MdPsdkAvP39ZpveJscOdLxU9dn3OEcC5q6Mqs1TOY/9axJlN/k+rQ1AgCAFEhpD7WZ9UWktslky5npFB2+d4UYa338ta9DuNbk6FabaNgVptsa40FMBAAAKZCKHmotlZwipqgYgyCT29xYWForqhqO1jRV5gghenZUNZbUe8a6pye6X20Pu+4ulck4BNoaAQBACqTuLt8iLH6Zb7qLEjS1V7eICsd+M7fsjmLu1s766uJi+yYhhBAl9WrUY3iZDUsbY03VYU3UAwAAN5ak/6JgxEuJdSvEmB/xp/Yy4S7WJrvRI2bE8HWiXScU7en8oiAAAEix1P0ONQAAAG5cH0t3AQAAAHADIDUCAADAGKkRAAAAxkiNAAAAMEZqBAAAgLHpV65cSXcZAAAAkOm48w4AAACM0UMNAAAAY6RGAAAAGCM1AgAAwBipEQAAAMZIjQAAADBGagQAAIAxUiMAAACMZXJqHHq1Or/66FDqd2qvfi3FewUAAMhwmZwaAQAAkCmmp7sAmSZnWVPvsnQXAgAAINMkv61x8LVqR7599N+OnrHZQ0drx2aO74a+vn7xlg7thoZerR7bjqYHeehorX3HedG9Y3TRjvNCCNG9Q7svIYQQ5+sdta8O6ouk3XXPjgjbBwAAgEh6ahx8rbp4q+tIr79P/ttSIIQQYuhorXuT89jozCOuTcWj6W3c+p07StSGhl6tLt4y64jczrFZW93aYPdSlb1KHOvr9fcdqX2pqr5biDucC/Ql8XqFMz9XtwvNroUo2NLr7+v17CwRAAAAGC+5qbHn5a2nHjqytVA3e6i9pWPBzpqC0cm5tTtLTrV0DAkx9JMTkdYXYrCjraPm2Ja5cqrg6/ULOk60D6rFNcdG8+gdzhLh7R8SuS6XHH5BnwAACeNJREFU8PUOymbFcY2O43dxfdcAAACIIanjGod6L4sF5XeEzf+1r0O41uSo6ZyZTtHhe1cI4e0QYk2ELf3ad0rsP+XYr5lVUnr9ofNTY1tSoxKdJR2+X4uh/hOiRLR2iwLhO1XifEaId70d4qUO+0vaLS2e7AECAABMFUlNjTn5s8QW76+FyBk//w5niWjrHxKFo/OH+n2iZPGnhHg32pbucC4QNXVjHdwmd+0TQ+0tzrp6Z8PL54dcPjGrNEcI4SoRD63xjzVbAgAAwIzk9lAXfLFGyIGG4+QsLC85tWn/aMfx4GubN3XUrvlKzuj6bT1CjA5k7Bh7Rm5Jacn+CnmlizmfcpV4/+/+tlmlBbklpZfb2oVY4LpDCJHz+cULIhQJAAAAsST5zjuFW/xHhL0qv3F0enQAYk5l4zFvfsVYj3Ptkd7RgYaFW449NDp/wc7OY7OKG0afmLOsqVNUF9sdY1suqfc0fUXXhqmVM9N5atP+2iNbhBALy33uTR21R3KEECL3K02doro43z625oKdnU2VOUKcr3dUjZWzw+3YqhkuCQAAMNVNu3btWrrLAAAAgEzHb8MAAADAGKkRAAAAxkiNAAAAMEZqBAAAgDFSIwAAAIxNv3LlSrrLAAAAgEzHnXcAAABgjB5qAAAAGCM1AgAAwBipEQAAAMZIjQAAADCWutRod+RHfHxDi3EgEz1G3fqGT5/o+gAAAPGYntStx0g22sf+vt6I62sX3Vjkgdw0hwMAAJC6O+/YHfnadBgtP6lF8kEmBC9dGbQFiHgg5mfGWBpjpyL6ixNtfQAAgDglt61RS5tjzGcamY1iNEYKIXp25Fe8VHOsb0uB6cIMHa11b+oQQghRsqOzcVmuQRnU4/BGRPlYV8KI5VQzIwZE7VJdiIyWDg3zKwAAQKIkPTWqVrHwiBMt6CR9iF73DvcmsaOzN3ZYjCFGo2m0g9VOxt6gYf6L1tEfLZUCAADEL+mpMUY6jLZI9VCb3EXBll7/lgkUaajfJ0oWLzQdGXWd5iafEmMyNsPIqOubjt21DQAAkBDpaWtU4mwV03Q0j+uhHjpa6/au8bieH1360BH/lrlGGztf76hqHH08bmuGzYc6Cek4Nv+KERMBAEAKJP0a6mids+Zby1RoCw9SOZWN/kohunfYq8L2/VKV+6Ej/r5GMfhadXFV/Rd7txYOvVpdvKVDLu5wO7YKoQLl+XpHlXdnp78yR8jQ6dgRIzjGyMG6owgfl2myU97MLtSasTcFAAAQv+SmRl1fs5lrqMOfNUkl9R7ZvphbUloi2vqHRGHOsqbeZTIUtiz2NH0lR63c3dYoao5Vjs7IqVxTu6mqtXtLQeG4TZqJcbqD1ebdGE+PfbmPyT0CAAAkT+p6qMPnmExg/r5e8w1vkyNHOn7q+ow7nGNBU1dmtYbJ/KeeNYnym1yftkYAAJACKe2hNrO+iNQ2mWw5M52iw/euEGOtj7/2dQjXmhzdahMNu8J0W2M8iIkAACAFUtFDraWSU8QUFWMQZHKbGwtLa0VVw9GapsocIUTPjqrGknrPWPf0RPer7WHX3aUyGYdAWyMAAEiB1N3lW4TFL/NNd1GCpvbqFlHh2G/mlt1RzN3aWV9dXGzfJIQQoqRejXoML7NhaWOsqTqsiXoAAODGkvRfFIx4KbFuhRjzI/7UXibcxdpkN3rEjBi+TrTrhKI9nV8UBAAAKZa636EGAADAjetj6S4AAAAAbgCkRgAAABgjNQIAAMAYqREAAADGSI0AAAAwNv3KlSvpLgMAAAAyHXfeAQAAgDF6qAEAAGCM1AgAAABjpEYAAAAYIzUCAADAGKkRAAAAxkiNAAAAMEZqBAAAgLEUpMbfvP6Ph26//fXXB8bN/Y83Xr/99kOj/3b/IvnFAAAAwOQlOTUOdNbe3inKZuhm/8cbr889fuv59x58770H33vvc5t3/az2jd8ktyQAAACIQ1JT429e3/b7h9974IG/0i94tz8kZv/FX45OzfjU/cksBQAAAOI2PZkbv/WB798XccHdy+4sL/zZ7UK8t+Gv/+ONzro3Z/zr929NZkkAAAAQl6Smxujyihvfc77+j+233/4zcf+d598r/kvj5wAAACBt0nUN9S+eu729bvbn3ntvYYP41dywa2UAAACQUdKTGs/t/tkz9995fsNfC3HrA99f2HB/qO5VLqMGAADIXGlJjb/594tCczXMrX81Ox2lAAAAgGlpSY233ltmEbvePyenBjpf3CXKZ+rvzgMAAIDMMe3atWvJ2/q53Yf+bte4OZv/z4PrC/SLyvcubPyfXEMNAACQuZKbGgEAAHBz4HeoAQAAYIzUCAAAAGOkRgAAABgjNQIAAMAYqREAAADGpl+5ciXdZQAAAECm4847AAAAMEYPNQAAAIyRGgEAAGCM1AgAAABjpEYAAAAYIzUCAADAGKkRAAAAxkiNAAAAMEZqBAAAgDFSIwAAAIyRGgEAAGCM1AgAAABjpEYAAAAYIzUCAADAWLJT4/l6R7597F999/UFPTuuz7fvOK/mDx2tvT6/+rUhtWDwterrm6p9dXCq7AIAACATTLt27Vq6ywAAAIBMRw81AAAAjJEaAQAAYIzUCAAAAGOkRgAAABgjNQIAAMAYqREAAADGSI0AAAAwRmoEAACAselXrlxJdxkAAACQ6fhtGAAAABijhxoAAADGSI0AAAAwRmoEAACAMVIjAAAAjJEaAQAAYIzUCAAAAGNmU+Ob5z9KajkAAACQyUylxjfPf7T9x1e3//hqsksDAACAzGQqNX5h9vT83I/L7PhhiLuCAwAATDlmfxvmw9C1b+z/z97BP87K+/jz1X/+Scu0ZJcMAAAAmcPsuMZPWqa9UPPnBTM/fnngj2ua/pMWRwAAgCllgtdQT5smhOCXqwEAAKaa6SbX+zB0bU3Tf14e+GN+7sdfqKGHGgAAYGoxlRpVZFw69xP/q9xCZAQAAJhqTKXGf7v4BxkZH//yLckuEAAAADKQqdR4/9xPqP8BAAAwBZm98w4AAACmMn6HGgAAAMZIjQAAADBGagQAAIAxUiMAAACMkRoBAABgjNQIAAAAY6RGAAAAGCM1AgAAwBipEQAAAMZIjQAAADBGagQAAIAxUiMAAACMkRoBAABgjNQIAAAAY6RGAAAAGCM1AgAAwBipEQAAAMZIjQAAADBGagQAAIAxUiMAAACMkRoBAABgjNQIAAAAY6RGAAAAGCM1AgAAwBipEQAAAMZIjQAAADBGagQAAIAxUiMAAACMkRoBAABgjNQIAAAAY6RGAAAAGCM1AgAAwBipEQAAAMZIjQAAADBGagQAAIAxUiMAAACMkRoBAABgjNQIAAAAY6RGAAAAGCM1AgAAwNj/B/8ztM2aJmbGAAAAAElFTkSuQmCC" alt=""></p></li><li><p>于是我们就可以在这两个方法上下功夫，首先我们定义一个Depend类</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Depend</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">allFn</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">adddepend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeFn) &#123;</span><br><span class="line">       <span class="variable language_">this</span>.<span class="property">allFn</span>.<span class="title function_">push</span>(activeFn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">allFn</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">fn</span>) =&gt;</span> <span class="title function_">fn</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//在constructor方法中定义一个函数，每次实例化这个类的时候都需要创建一个新的数组，用于放置需要执行的函数，如果我们将所有的函数都丢在一个数组内，那我们就没办法作区分了，不同的属性修改了他们是可能会有不同的回调，</span></span><br><span class="line"><span class="comment">//然后在定义一个adddepend函数，用于将函数push进数组中</span></span><br><span class="line"><span class="comment">//最后我们定义了一个notify的函数，用于执行allFn数组内的所有函数</span></span><br></pre></td></tr></table></figure></li><li><p>我们前面说过当我们获取对象的值的时候我们会来到get方法，所以我们可以在get方法中将收集依赖，我们修改下Proxy的方法，但是这个有个问题，我们在调用set方法的adddepend时候，需要给他传递调用watchFn里面的函数，所以我们可以定义一个全局变量 ，用于保存这个函数，于是定义的watchFn的函数需要稍微修改下</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeFn = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchFn</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  activeFn = fn;</span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">  activeFn = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>然后重新回到定义infoProxy的地方，再对代码进行一点修改</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//首先我们先封装一个方法，用于获取每个属性对应的depend</span></span><br><span class="line"><span class="keyword">const</span> weMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDepend</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> map = weMap.<span class="title function_">get</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (!map) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    weMap.<span class="title function_">set</span>(target, map);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> depend = map.<span class="title function_">get</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (!depend) &#123;</span><br><span class="line">    depend = <span class="keyword">new</span> <span class="title class_">Depend</span>();</span><br><span class="line">    map.<span class="title function_">set</span>(key, depend);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depend;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后修改下Proxy的代码</span></span><br><span class="line"><span class="keyword">const</span> infoProxy =  <span class="keyword">new</span> <span class="title class_">Proxy</span>(info, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, recesver</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> depend = <span class="title function_">getDepend</span>(target, key);</span><br><span class="line">      depend.<span class="title function_">adddepend</span>(activeFn);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, recesver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, newValue, recesver</span>) &#123;</span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, recesver);</span><br><span class="line">      <span class="keyword">const</span> depend = <span class="title function_">getDepend</span>(target, key);</span><br><span class="line">      depend.<span class="title function_">notify</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>这里用到了WeakMap，WeakMap和Map最大的区别就是前者的键是一个对象，并且这是一个弱引用，首先我们通过get方法可以拿到这个对象的Map，判断下有没有值，第一次都是没有值的，如果没有值我们就给他初始化一个Map，然后在根据对象的key，拿到这个key所对应的依赖，当然，如果没有我们也需要初始化一个我们定义的Depend，最后将这个依赖返回出去，我们就可以在调用的时候根据对象和key拿到对应的依赖，从而执行他们对应的依赖</p></li><li><p>这里也用到了Reflect，他是ES6新增的一个内置对象，他提供了拦截JS操作的方法，为什么会出现这个方法呢？在我看来，在早期的JS中，有些东西是考虑不周到的，设计的也不合理，所以一些Objcet对象下有很多方法压根就不能属于他，放在它身上很不合适，所以导致Object这个对象特别臃肿。<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Reflect">MDN上对Reflect的详细解释</a></p></li><li><p>于是我们就完成了Vue3的响应式原理，当数据发生变化的时候就会触发对应的回调</p></li></ol><h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol><li>紧接着我们来重构下部分代码，目前来说代码有点bug，虽然不影响功能，但是当我们watchFn中的函数多次用到了代理对象的值，那么在触发依赖的时候就会多次执行，因为每次获取一次对象的值的时候，都会来到get方法，然后将这个函数存起来，明明都是同一个函数并且还是同一个key的依赖，没必要多次执行浪费性能。所以我们可以将数组更换为set</li><li>其次就是当我们有多个对象需要拦截的时候，难道我们都写一次Proxy方法吗？明显不现实，所以我们可以将拦截对象对的get和set方法的操作封装成一个函数</li></ol><h4 id="最终代码"><a href="#最终代码" class="headerlink" title="最终代码"></a>最终代码</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> activeFn = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Depend</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">allFn</span> = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">adddepend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeFn) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">allFn</span>.<span class="title function_">add</span>(activeFn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">allFn</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">fn</span>) =&gt;</span> <span class="title function_">fn</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchFn</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  activeFn = fn;</span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">  activeFn = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;coderwei&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> weMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDepend</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> map = weMap.<span class="title function_">get</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (!map) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    weMap.<span class="title function_">set</span>(target, map);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> depend = map.<span class="title function_">get</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (!depend) &#123;</span><br><span class="line">    depend = <span class="keyword">new</span> <span class="title class_">Depend</span>();</span><br><span class="line">    map.<span class="title function_">set</span>(key, depend);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depend;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//然后修改下Proxy的代码</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Proxy</span>(info, &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params">target, key, recesver</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> depend = <span class="title function_">getDepend</span>(target, key);</span><br><span class="line">      depend.<span class="title function_">adddepend</span>(activeFn);</span><br><span class="line">      <span class="keyword">return</span> <span class="title class_">Reflect</span>.<span class="title function_">get</span>(target, key, recesver);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">target, key, newValue, recesver</span>) &#123;</span><br><span class="line">      <span class="title class_">Reflect</span>.<span class="title function_">set</span>(target, key, newValue, recesver);</span><br><span class="line">      <span class="keyword">const</span> depend = <span class="title function_">getDepend</span>(target, key);</span><br><span class="line">      depend.<span class="title function_">notify</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> infoProxy = <span class="title function_">reactive</span>(info);</span><br><span class="line"></span><br><span class="line"><span class="comment">// name发生变化需要执行的逻辑</span></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;name:&quot;</span>, infoProxy.<span class="property">name</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// age发生变化需要执行的逻辑</span></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;age:&quot;</span>, infoProxy.<span class="property">age</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">infoProxy.<span class="property">age</span> = <span class="number">99988</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="Vue2的响应式"><a href="#Vue2的响应式" class="headerlink" title="Vue2的响应式"></a>Vue2的响应式</h3><ol><li><p>基本上大同小异，只是劫持对象用的方法不一样，Vue3用的Proxy，Vue2用的Object.defineProperty，唯一不同的地方也就在这里，我就直接贴上我的代码了，如果有疑问可以联系我</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 勿在浮沙筑高</span></span><br><span class="line"><span class="keyword">let</span> activeFn = <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装一个Depend类  用于收集依赖</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Depend</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">allFn</span> = <span class="keyword">new</span> <span class="title class_">Set</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">addDepend</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (activeFn) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">allFn</span>.<span class="title function_">add</span>(activeFn);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">notify</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">allFn</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">fn</span>) =&gt;</span> <span class="title function_">fn</span>());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> info = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;coderwhy&quot;</span>,</span><br><span class="line">  <span class="attr">age</span>: <span class="number">18</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// vue2 ====&gt; Object.defineProperty</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reactive</span>(<span class="params">obj</span>) &#123;</span><br><span class="line">  <span class="title class_">Object</span>.<span class="title function_">keys</span>(obj).<span class="title function_">forEach</span>(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> value = obj[key];</span><br><span class="line">    <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(obj, key, &#123;</span><br><span class="line">      <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> depend = <span class="title function_">getDepend</span>(obj, key);</span><br><span class="line">        depend.<span class="title function_">addDepend</span>();</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">        value = newValue;</span><br><span class="line">        <span class="keyword">const</span> depend = <span class="title function_">getDepend</span>(obj, key);</span><br><span class="line">        depend.<span class="title function_">notify</span>();</span><br><span class="line">      &#125;,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装响应式函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">watchFn</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">  activeFn = fn;</span><br><span class="line">  <span class="title function_">fn</span>();</span><br><span class="line">  activeFn = <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 封装获取正确的depend   ===========&gt;WeakMap</span></span><br><span class="line"><span class="keyword">let</span> wMap = <span class="keyword">new</span> <span class="title class_">WeakMap</span>();</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">getDepend</span>(<span class="params">target, key</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> map = wMap.<span class="title function_">get</span>(target);</span><br><span class="line">  <span class="keyword">if</span> (!map) &#123;</span><br><span class="line">    map = <span class="keyword">new</span> <span class="title class_">Map</span>();</span><br><span class="line">    wMap.<span class="title function_">set</span>(target, map);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> depend = map.<span class="title function_">get</span>(key);</span><br><span class="line">  <span class="keyword">if</span> (!depend) &#123;</span><br><span class="line">    depend = <span class="keyword">new</span> <span class="title class_">Depend</span>();</span><br><span class="line">    map.<span class="title function_">set</span>(key, depend);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> depend;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> infoProxy = <span class="title function_">reactive</span>(info);</span><br><span class="line"></span><br><span class="line"><span class="comment">// name发生变化需要执行的逻辑</span></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(infoProxy.<span class="property">name</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// age发生变化需要执行的逻辑</span></span><br><span class="line"><span class="title function_">watchFn</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(infoProxy.<span class="property">age</span>);</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;-------------&quot;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> test = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;test&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> testProxy = <span class="title function_">reactive</span>(test);</span><br><span class="line">infoProxy.<span class="property">name</span> = <span class="string">&quot;zys&quot;</span>;</span><br><span class="line">infoProxy.<span class="property">age</span> = <span class="string">&quot;1999&quot;</span>;</span><br><span class="line"><span class="title function_">watchFn</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(testProxy.<span class="property">name</span>);</span><br><span class="line">&#125;);</span><br><span class="line">testProxy.<span class="property">name</span> = <span class="string">&quot;123&quot;</span>;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> JavaScript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/post/0.html"/>
      <url>/post/0.html</url>
      
        <content type="html"><![CDATA[<h2 id="vite环境下实现动态路由和webpack的不同"><a href="#vite环境下实现动态路由和webpack的不同" class="headerlink" title="vite环境下实现动态路由和webpack的不同"></a>vite环境下实现动态路由和webpack的不同</h2><h3 id="require-context和import-meta-glob"><a href="#require-context和import-meta-glob" class="headerlink" title="require.context和import.meta.glob"></a>require.context和import.meta.glob</h3><p>今天在练习vite项目的时候，需要查询项目中的某个文件，在以前的webpack环境下，可以通过require.context来查询，他可以接受三个参数，第一个是目录，第二个是是否开启递归查询，第三个则是一个正则表达式，要查询那些文件。然后到vite中也有这种需求，经过一番查询，发现其实本质上差不多。<a href="https://vitejs.cn/guide/features.html#glob-import">文档地址</a>，下面是两种环境下的写法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> modulesFiles = <span class="built_in">require</span>.<span class="title function_">context</span>(<span class="string">&#x27;../router/main&#x27;</span>, <span class="literal">true</span>, <span class="regexp">/\.ts$/</span>) <span class="comment">// webpack</span></span><br><span class="line"><span class="keyword">const</span> modules = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>(<span class="string">&#x27;../router/main/**/*.ts&#x27;</span>) <span class="comment">//vite写法1</span></span><br><span class="line"><span class="keyword">const</span> modules = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">globEager</span>(<span class="string">&quot;../router/main/**/*.ts&quot;</span>) <span class="comment">// vite写法2</span></span><br><span class="line"><span class="comment">//vite有两种写法：第一种在打包时会进行分包处理，第二钟则不会</span></span><br></pre></td></tr></table></figure><p>我的需求是需要拿到router文件夹下面定义的一个个router对象，这个对象是我手动定义的，然后根据拿到的对象来做动态路由的加载，大家可以根据自己不同的需求进行修改。vite中如果需要递归查询可以用<a href="https://github.com/mrmlnc/fast-glob#pattern-syntax">**代表任意目录</a>。</p><p>在拿到modules后如何去拿一个个模块对象呢？官方的例子：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> path <span class="keyword">in</span> modules) &#123;</span><br><span class="line">  modules[path]().<span class="title function_">then</span>(<span class="function">(<span class="params">mod</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(path, mod)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过遍历拿到modules对象的每个键，然后他的值是一个函数，执行后会返回一个promise，通过then的方法进行调用就可以拿到对应的一个个模块。这种案例不符合我的需求，因为用then方法实际上是一个微任务，他会被加入微任务队列，并不会立刻执行，所以我们在外面拿不到这一个个的模块的。就像这样</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">RouteRecordRaw</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;vue-router&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">function</span> <span class="title function_">mapMenus</span>(<span class="params"></span>): <span class="title class_">RouteRecordRaw</span>[] &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">RouteRecordRaw</span>[] = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> <span class="attr">allRoutes</span>: <span class="title class_">RouteRecordRaw</span>[] = []</span><br><span class="line">  <span class="keyword">const</span> modules = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>(<span class="string">&#x27;../router/**/*.ts&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> path <span class="keyword">in</span> modules) &#123;</span><br><span class="line">      modules[path]().<span class="title function_">then</span>(<span class="function">(<span class="params">mod</span>) =&gt;</span> &#123;</span><br><span class="line">          <span class="variable language_">console</span>.<span class="title function_">log</span>(path, mod)</span><br><span class="line">      &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(allRoutes)<span class="comment">//无论如何这里都是一个空对象，因为这个先执行，然后再去执行微任务</span></span><br><span class="line">  <span class="keyword">return</span> routes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果还是不懂可以去看我之前的一篇文章，有讲到关于js的事件循环。所以我们可以利用async和await对上面代码进行一点改造</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">async</span> <span class="keyword">function</span> <span class="title function_">mapMenus</span>(<span class="params"></span>): <span class="title class_">Promise</span>&lt;<span class="title class_">RouteRecordRaw</span>[]&gt; &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">routes</span>: <span class="title class_">RouteRecordRaw</span>[] = []</span><br><span class="line">  <span class="keyword">const</span> <span class="attr">allRoutes</span>: <span class="title class_">RouteRecordRaw</span>[] = []</span><br><span class="line">  <span class="keyword">const</span> modules = <span class="keyword">import</span>.<span class="property">meta</span>.<span class="title function_">glob</span>(<span class="string">&#x27;../router/**/*.ts&#x27;</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> path <span class="keyword">in</span> modules) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = <span class="keyword">await</span> modules[path]()</span><br><span class="line">    allRoutes.<span class="title function_">push</span>(res.<span class="property">default</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(allRoutes)</span><br><span class="line">  <span class="keyword">return</span> routes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们就可以继续对获取到的模块进行操作的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/post/0.html"/>
      <url>/post/0.html</url>
      
        <content type="html"><![CDATA[<h1 id="初识webpack5"><a href="#初识webpack5" class="headerlink" title="初识webpack5"></a>初识webpack5</h1><h2 id="为什么需要webpack"><a href="#为什么需要webpack" class="headerlink" title="为什么需要webpack"></a>为什么需要webpack</h2><p>再传统的项目开发中，我们会手动引入项目需要的各个文件，这会带来一个问题，如果我们某个文件依赖另一个文件，那么代码的书写顺序或者是引入的顺序就不能颠倒，不然可能会造成项目崩溃。也不方便后续维护。当然如果我们将所有的文件合并到一个js文件中，确实解决了引入顺序的问题，但是他导致我们的文件过大，如果我们分批加载，用户能够一点点的看到界面的内容，但是但我们合并到一个文件，那么这个文件会变得非常臃肿，界面可能会白屏一段时间才能加载出来，这在项目上线后是致命的。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>集合类型</title>
      <link href="/post/8d0808f2.html"/>
      <url>/post/8d0808f2.html</url>
      
        <content type="html"><![CDATA[<h1 id="集合类型"><a href="#集合类型" class="headerlink" title="集合类型"></a>集合类型</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>在计算机科学中，<strong>集合</strong>是一组可变数量的数据项（也可能是0个）的组合，这些数据项可能共享某些特征，需要以某种操作方式一起进行操作。一般来讲，这些数据项的类型是相同的。几乎所有语言中都有集合的存在，常见的实现方式就是哈希表。目前先用js中的对象实现一下。</p><p>集合通常有两个特点，第一个就是无序，第二个就是不允许重复。和ES6提供的Set比较相似。</p><h2 id="集合中常见的方法"><a href="#集合中常见的方法" class="headerlink" title="集合中常见的方法"></a>集合中常见的方法</h2><ol><li>add：向集合中添加一个元素</li><li>remove：从集合从移除一个元素</li><li>has：如果集合包含某个元素旧返回true，反之返回false</li><li>clear：移除集合中所有的元素</li><li>size：返回集合中元素的数量</li><li>values：返回集合中所有的元素</li><li>并集操作</li><li>交集操作</li><li>差集操作</li></ol><h2 id="在js中实现集合类型"><a href="#在js中实现集合类型" class="headerlink" title="在js中实现集合类型"></a>在js中实现集合类型</h2><p>当我们借助于js的对象来实现集合类型的时候就会显的非常简单</p><h3 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MySet</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>因为集合就是一个个的对象，我们在类中创建的对象已经能够满足集合的需求，它不像链表一样那么复杂，需要包含指向上一个节点或者是下一个节点的引用</p></blockquote><h3 id="实现add方法"><a href="#实现add方法" class="headerlink" title="实现add方法"></a>实现add方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// add：向集合中添加一个元素</span></span><br><span class="line"><span class="title function_">add</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="title function_">has</span>(data)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span>[data] = data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现remove方法"><a href="#实现remove方法" class="headerlink" title="实现remove方法"></a>实现remove方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remove：从集合从移除一个元素</span></span><br><span class="line"><span class="title function_">remove</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (!<span class="variable language_">this</span>.<span class="title function_">has</span>(data)) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">delete</span> <span class="variable language_">this</span>.<span class="property">items</span>[data];</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现has方法"><a href="#实现has方法" class="headerlink" title="实现has方法"></a>实现has方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// has：如果集合包含某个元素旧返回true，反之返回false</span></span><br><span class="line"><span class="title function_">has</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="variable language_">this</span>.<span class="property">items</span>).<span class="title function_">includes</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现clear方法"><a href="#实现clear方法" class="headerlink" title="实现clear方法"></a>实现clear方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// clear：移除集合中所有的元素</span></span><br><span class="line"><span class="title function_">clear</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span> = &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现size方法"><a href="#实现size方法" class="headerlink" title="实现size方法"></a>实现size方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// size：返回集合中元素的数量</span></span><br><span class="line"> <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">keys</span>(<span class="variable language_">this</span>.<span class="property">items</span>).<span class="property">length</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="实现values方法"><a href="#实现values方法" class="headerlink" title="实现values方法"></a>实现values方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// values：返回集合中所有的元素</span></span><br><span class="line"><span class="title function_">values</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Object</span>.<span class="title function_">values</span>(<span class="variable language_">this</span>.<span class="property">items</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现并集操作"><a href="#实现并集操作" class="headerlink" title="实现并集操作"></a>实现并集操作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并集操作</span></span><br><span class="line"><span class="title function_">union</span>(<span class="params">outher</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">MySet</span>();</span><br><span class="line">  <span class="keyword">let</span> value = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">  value.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    set.<span class="title function_">add</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">  value = outher.<span class="title function_">values</span>();</span><br><span class="line">  value.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    set.<span class="title function_">add</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现交集操作"><a href="#实现交集操作" class="headerlink" title="实现交集操作"></a>实现交集操作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 交集操作</span></span><br><span class="line"><span class="title function_">intersection</span>(<span class="params">other</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">MySet</span>();</span><br><span class="line">  <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">  <span class="keyword">const</span> otherValue = other.<span class="title function_">values</span>();</span><br><span class="line">  <span class="keyword">const</span> arr = value.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> otherValue.<span class="title function_">includes</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    set.<span class="title function_">add</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现差集操作"><a href="#实现差集操作" class="headerlink" title="实现差集操作"></a>实现差集操作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 差集操作</span></span><br><span class="line"><span class="title function_">difference</span>(<span class="params">other</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">MySet</span>();</span><br><span class="line">  <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">  <span class="keyword">const</span> otherValue = other.<span class="title function_">values</span>();</span><br><span class="line">  <span class="keyword">const</span> arr = value.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> !otherValue.<span class="title function_">includes</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">  arr.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    set.<span class="title function_">add</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> set;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现子集操作"><a href="#实现子集操作" class="headerlink" title="实现子集操作"></a>实现子集操作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子集操作</span></span><br><span class="line"><span class="title function_">subset</span>(<span class="params">other</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> value = <span class="variable language_">this</span>.<span class="title function_">values</span>();</span><br><span class="line">  <span class="keyword">const</span> otherValue = other.<span class="title function_">values</span>();</span><br><span class="line">  <span class="keyword">const</span> arr = value.<span class="title function_">filter</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> otherValue.<span class="title function_">includes</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">if</span> (arr.<span class="property">length</span> !== <span class="variable language_">this</span>.<span class="title function_">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>双向链表</title>
      <link href="/post/37fd9ed5.html"/>
      <url>/post/37fd9ed5.html</url>
      
        <content type="html"><![CDATA[<h1 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h1><h2 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h2><p>在计算机科学中，双向链表又被称为<strong>双链表</strong>，也属于链表，但是他每个节点都有两个指针，指向他前一个节点和后一个节点。我们学习单向链表的时候会发现，我们只能从前端遍历到尾端或者是尾端遍历到前端，因为单向链表正如其名：<strong>单向</strong>，所以说我们可以轻松的得到下一个节点，但是想回到上一个节点是很难的。但是双向链表就不一样的，他每个节点不单单保存着他下一个节点，还保存着他上一个节点，对于操作的方便程度是单向链表无法比拟的。当然，它占用的内存也会大一些</p><h2 id="双向链表常见的方法"><a href="#双向链表常见的方法" class="headerlink" title="双向链表常见的方法"></a>双向链表常见的方法</h2><ol><li>append：向链表后端新增一个节点</li><li>insert：在指定位置插入一个节点</li><li>get：返回指定位置的节点</li><li>indexOf：返回指定节点在链表的索引，找不到则返回-1</li><li>update：修改某个位置的节点</li><li>removeAt：移除指定位置的节点</li><li>remove：移除链表后端的节点</li><li>isEmpty：判断链表有没有节点，有则返回true，反之返回false</li><li>size：返回链表的节点个数</li><li>toString：输出链表的节点，因为实际上我们只需要节点的value，所以需要封装个方法打印出所有的value</li><li>forwarrdString：从前端遍历到后端，打印出所有节点的value</li><li>backwordString：从后端遍历到前端，打印出所有节点的value</li><li>getHead：返回链表前端的节点</li><li>getTail：返回链表后端的节点</li></ol><h2 id="在js中实现双向链表"><a href="#在js中实现双向链表" class="headerlink" title="在js中实现双向链表"></a>在js中实现双向链表</h2><h3 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="comment">//当前节点的value</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = data;</span><br><span class="line">    <span class="comment">//保存上一个节点信息</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">prev</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//保存下一个节点信息</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">DoubleList</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">//头部节点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//尾部节点</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="comment">//链表长度</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>先封装个节点类和双向链表类，每一个节点我们都是实例化一个Node类保存到链表的。</p><blockquote><p>以下所有方法都在DoubleList类中实现</p></blockquote><h3 id="实现append方法"><a href="#实现append方法" class="headerlink" title="实现append方法"></a>实现append方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// append方法：在链表后端插入一个节点</span></span><br><span class="line"><span class="title function_">append</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">  <span class="comment">//分情况处理：判断是否是第一个节点</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = node;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">while</span> (current.<span class="property">next</span>) &#123;</span><br><span class="line">      current = current.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    node.<span class="property">prev</span> = current;</span><br><span class="line">    current.<span class="property">next</span> = node;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = node;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>append方法比较简单，只是在处理节点的时候需要考虑到上一个节点的保存，别忘记在新增后需要将length加1</p><h3 id="实现-insert方法"><a href="#实现-insert方法" class="headerlink" title="实现 insert方法"></a>实现 insert方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// insert方法：在指定位置插入元素</span></span><br><span class="line"><span class="title function_">insert</span>(<span class="params">position, data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">  <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  <span class="comment">// 先判断插入第一个元素的情况</span></span><br><span class="line">  <span class="keyword">if</span> (position == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = node;</span><br><span class="line">    node.<span class="property">next</span> = current;</span><br><span class="line">    current.<span class="property">prev</span> = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === <span class="variable language_">this</span>.<span class="property">length</span>) &#123;</span><br><span class="line">    <span class="comment">//判断插入的是最后一个节点的情况</span></span><br><span class="line">    <span class="keyword">while</span> (current.<span class="property">next</span>) &#123;</span><br><span class="line">      current = current.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    current.<span class="property">next</span> = node;</span><br><span class="line">    node.<span class="property">prev</span> = current;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">tail</span> = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//在中间的情况</span></span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> prive = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; position) &#123;</span><br><span class="line">      prive = current;</span><br><span class="line">      current = current.<span class="property">next</span>;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">    prive.<span class="property">next</span> = node;</span><br><span class="line">    node.<span class="property">prev</span> = prive;</span><br><span class="line">    current.<span class="property">prev</span> = node;</span><br><span class="line">    node.<span class="property">next</span> = current;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>insert方法就比较麻烦，分的情况也比较多，首先需要考虑插入的是第一个节点的情况，先看图：</p><p><img src="https://i.bmp.ovh/imgs/2021/11/b8b1224c5059dfe3.png" alt="默认情况"></p><p>我们可以看到默认情况双向链表的结构，head会指向第一个节点，tail会指向最后一个节点，然后每个节点有个next属性指向下一个节点，也有一个prev属性指向上一个节点</p><p><img src="https://i.bmp.ovh/imgs/2021/11/12c204476512214c.png" alt="插入后的指针指向"></p><p>我们会发现head指向value为4的节点，然后value为4的节点的next指向value为1的节点，然后节点value为1的节点的prev指向value为4的节点，也就是他上一个节点</p><p>当插入最后也是同理，value为3的节点的next属性指向value为4的节点，value为4的节点的prev属性指向value为3的节点，然后继续将tail指向最后一个节点，也就是value为4的节点。</p><h3 id="实现get方法"><a href="#实现get方法" class="headerlink" title="实现get方法"></a>实现get方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// get方法：获取指定位置的元素</span></span><br><span class="line"><span class="title function_">get</span>(<span class="params">position</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> / <span class="number">2</span> &gt; position) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; position) &#123;</span><br><span class="line">      current = current.<span class="property">next</span>;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.<span class="property">data</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">tail</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; <span class="variable language_">this</span>.<span class="property">length</span> - position - <span class="number">1</span>) &#123;</span><br><span class="line">      current = current.<span class="property">prev</span>;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> current.<span class="property">data</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>get方法就比较简单，和单向链表相似，值得注意的是，如果我们链表中有大量数据，那么无论什么时候都从头找到尾明显不合适，所以可以判断一下需要找的元素的位置偏向前面还是偏向后面，决定我们从前开始找还是从后开始找，有点类似于二分查找，不过我们只分一次，这也是单向链表做不到的</p><h3 id="实现indexOf方法"><a href="#实现indexOf方法" class="headerlink" title="实现indexOf方法"></a>实现indexOf方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// indexOf方法： 返回元素的索引，没有锗元素就返回-1</span></span><br><span class="line"> <span class="title function_">indexOf</span>(<span class="params">data</span>) &#123;</span><br><span class="line">   <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">   <span class="keyword">while</span> (current) &#123;</span><br><span class="line">     <span class="keyword">if</span> (current.<span class="property">data</span> === data) &#123;</span><br><span class="line">       <span class="keyword">return</span> index;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       current = current.<span class="property">next</span>;</span><br><span class="line">       index++;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h3 id="实现update方法"><a href="#实现update方法" class="headerlink" title="实现update方法"></a>实现update方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// update方法： 更新方法</span></span><br><span class="line"><span class="title function_">update</span>(<span class="params">position, data</span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; position) &#123;</span><br><span class="line">    current = current.<span class="property">next</span>;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">  current.<span class="property">data</span> = data;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现removeAt方法"><a href="#实现removeAt方法" class="headerlink" title="实现removeAt方法"></a>实现removeAt方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// removeAt方法：移除特定位置的元素</span></span><br><span class="line"> <span class="title function_">removeAt</span>(<span class="params">position</span>) &#123;</span><br><span class="line">   <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">   <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">   <span class="keyword">let</span> prive = <span class="literal">null</span>;</span><br><span class="line">   <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="literal">null</span>;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//一样先判断在移除第一个节点的情况</span></span><br><span class="line">   <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">head</span> = current.<span class="property">next</span>;</span><br><span class="line">     current.<span class="property">next</span>.<span class="property">prev</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position === <span class="variable language_">this</span>.<span class="property">length</span> - <span class="number">1</span>) &#123;</span><br><span class="line">     <span class="comment">//判断移除最后一个节点的情况</span></span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">prev</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">     <span class="variable language_">this</span>.<span class="property">tail</span> = <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">prev</span>;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     <span class="comment">//移除中间节点的情况</span></span><br><span class="line">     <span class="keyword">while</span> (index &lt; position) &#123;</span><br><span class="line">       prive = current;</span><br><span class="line">       current = current.<span class="property">next</span>;</span><br><span class="line">       index++;</span><br><span class="line">     &#125;</span><br><span class="line">     prive.<span class="property">next</span> = current.<span class="property">next</span>;</span><br><span class="line">     current.<span class="property">next</span>.<span class="property">prev</span> = prive;</span><br><span class="line">     <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="variable language_">this</span>.<span class="property">legnth</span>--;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>removeAt方法稍微复杂一点点，大部分情况都是在考虑节点引用的问题，在移除最后一个节点的时候，也要注意移除顺序，如果我们选择现在将tail指向最后一个节点的上一个，那么我们找到倒数第二个节点的时候就找不到了，因为我们拿不到最后一个节点了，所以需要先将最后一个节点的上一个节点的next先置为空，然后在处理tail的指向。</p><h3 id="实现remove方法"><a href="#实现remove方法" class="headerlink" title="实现remove方法"></a>实现remove方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// remove方法：移除某个元素</span></span><br><span class="line"> <span class="title function_">remove</span>(<span class="params">data</span>) &#123;</span><br><span class="line">   <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="title function_">indexOf</span>(data);</span><br><span class="line">   <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="title function_">removeAt</span>(index);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>先调用indexOf方法找到移除元素的索引，然后调用removeAt方法将索引传递进去接口</p><h3 id="实现isEmpty方法"><a href="#实现isEmpty方法" class="headerlink" title="实现isEmpty方法"></a>实现isEmpty方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// isEmpty方法： 判断链表是否为空，是则返回true，否则返回false</span></span><br><span class="line"><span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">legnth</span> &gt; <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现size方法"><a href="#实现size方法" class="headerlink" title="实现size方法"></a>实现size方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// size方法： 返回链表的长度</span></span><br><span class="line"><span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现getHead方法"><a href="#实现getHead方法" class="headerlink" title="实现getHead方法"></a>实现getHead方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getHead方法： 返回列表前端元素</span></span><br><span class="line"><span class="title function_">getHead</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">head</span>.<span class="property">data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现getTail方法"><a href="#实现getTail方法" class="headerlink" title="实现getTail方法"></a>实现getTail方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// getTail方法： 返回列表后端元素</span></span><br><span class="line"><span class="title function_">getTail</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">tail</span>.<span class="property">data</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单向链表</title>
      <link href="/post/b42a8d36.html"/>
      <url>/post/b42a8d36.html</url>
      
        <content type="html"><![CDATA[<h1 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>在计算机科学中，<strong>链表</strong>（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，单向链表在每一个节点里存到下一个节点的指针(Pointer)。简单来说，单向链表可以用来储存数据，他在内存中不必是连续的内存空间，链表每个元素由元素本身的值和指向下一个元素的引用组成。</p><h2 id="与数组比较"><a href="#与数组比较" class="headerlink" title="与数组比较"></a>与数组比较</h2><p>数组在通过下标获取元素或者是修改元素的性能比链表高，而链表在插入或者是删除元素的时候性能比数组高，因为数组在插入或者是删除的时候需要做大量的位移，他要给这个元素腾一个位置出来</p><h2 id="常见方法"><a href="#常见方法" class="headerlink" title="常见方法"></a>常见方法</h2><ol><li>append：向链表尾部添加一个新的元素</li><li>insert：向链表的特定位置插入一个新的元素</li><li>get：获取指定位置的元素</li><li>indexOf：返回指定元素在链表中的索引，如果没找到该元素，就返回-1</li><li>update：在链表修改指定位置的元素</li><li>removeAt：在链表删除指定位置的元素</li><li>remove：在链表删除指定元素</li><li>isEmpty：如果链表中不包含任何元素返回true，否则返回false</li><li>size：返回链表包含的元素个数</li><li>toString：输出链表中元素的值</li></ol><h2 id="在js中实现链表"><a href="#在js中实现链表" class="headerlink" title="在js中实现链表"></a>在js中实现链表</h2><h3 id="前置工作"><a href="#前置工作" class="headerlink" title="前置工作"></a>前置工作</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义一个元素的类，</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">data</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">data</span> = data;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">next</span> = <span class="literal">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义一个链表类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LinkedList</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span> = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好，首先我们先定义一个类Node，因为链表中每一个元素都不是一个普通的值，而是一个对象，他需要包含当前位置元素的值和他下一个元素的引用，要指向下一个元素，在链表钟我们是通过这个引用一个个的往后面找的，一旦这个指针断了，那么后面的元素就找不到了，这一点在后面写代码的时候要时刻注意。</p><p>然后我们定义一个链表类，构造器中有一个head，他代表着当前链表的第一个元素，我们在插入和删除的时候都需要考虑到第一个元素的情况，他们的处理逻辑是不同的。然后是一个length，他代表这这个链表的长度。</p><blockquote><p>注意下面所有方法都是定义在 LinkedList类中，为了简化代码，我就只写方法</p></blockquote><h3 id="实现append方法"><a href="#实现append方法" class="headerlink" title="实现append方法"></a>实现append方法</h3><p>实现插入方法也很简单，先看代码，再看分析</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在链表末端插入方法</span></span><br><span class="line"><span class="title function_">append</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="keyword">while</span> (current.<span class="property">next</span>) &#123;</span><br><span class="line">      current = current.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    current.<span class="property">next</span> = node;</span><br><span class="line">  &#125;</span><br><span class="line">  t <span class="title function_">get</span>(<span class="params">position</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 进行边缘判断</span></span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 寻找对应的元素</span></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">    current = current.<span class="property">next</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> current.<span class="property">data</span>;</span><br><span class="line">&#125;his.<span class="property">length</span>++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们插入元素需要考虑到当前元素是不是链表的第一个元素，如果是，我们只需要将head指向这个元素实例化的对象即可</p><p>如果不是第一个元素，我们首先需要声明一个变量，然后判断这个变量的next属性，也就是有没有保存下一个元素的引用，如果没有就代表他是最后一个元素了，那个时候我们只需要将他的next指定我们根据传进来的元素(data)实例化的对象(node)即可。如果有我们就继续判断他下一个元素的next有没有保存指向下一个元素的引用。</p><h3 id="实现insert方法"><a href="#实现insert方法" class="headerlink" title="实现insert方法"></a>实现insert方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">inster</span>(<span class="params">position, data</span>) &#123;</span><br><span class="line">  <span class="comment">// 1. 做边缘判断：position为负数和大于当前链表长度的情况</span></span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt; <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 2. 创建一个对象</span></span><br><span class="line">  <span class="keyword">const</span> node = <span class="keyword">new</span> <span class="title class_">Node</span>(data);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 3. 插入元素:需要考虑插入的元素是第一个的情况</span></span><br><span class="line">  <span class="keyword">if</span> (position == <span class="number">0</span>) &#123;</span><br><span class="line">    node.<span class="property">next</span> = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = node;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 当前元素</span></span><br><span class="line">    <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">    <span class="comment">// 上一个元素</span></span><br><span class="line">    <span class="keyword">let</span> prive = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">      prive = current;</span><br><span class="line">      current = current.<span class="property">next</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    prive.<span class="property">next</span> = node;</span><br><span class="line">    node.<span class="property">next</span> = current;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">length</span>++;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在指定位置插入一个元素就麻烦一点，还记得上面讲过，我们不能随随便便将一个元素置为空，这会导致这条线断了，后面的元素全找不到了。所以我们在插入的时候拿到上一个元素和下一个元素，并且保存起来。</p><p>举个例子：有十个小朋友拉着手一字排开，然后来了个新的小朋友，他要排到这个队伍第五个位置，所以我们只需要让原本第五个人的左手拉着这个新来的小朋友的右手，然后这个新来的小朋友的左手拉着第四个小朋友的右手就可以了。如何用代码复现呢？</p><p>当找到该插入的位置的时候，我们将上一个位置的元素的next指向当前插入的元素，然后将当前插入的元素的next属性指向本该排在这个位置的元素就可以了。</p><p><img src="https://i.bmp.ovh/imgs/2021/11/5f24305075a734a5.png" alt="插入之前"></p><p><img src="https://i.bmp.ovh/imgs/2021/11/60f929bbdd8072c6.png" alt="插入之后"></p><h3 id="实现get方法"><a href="#实现get方法" class="headerlink" title="实现get方法"></a>实现get方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 拿到指定位置的元素</span></span><br><span class="line"> <span class="title function_">get</span>(<span class="params">position</span>) &#123;</span><br><span class="line">   <span class="comment">// 1. 进行边缘判断</span></span><br><span class="line">   <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 2. 寻找对应的元素</span></span><br><span class="line">   <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">   <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">   <span class="keyword">while</span> (index++ &lt; position) &#123;</span><br><span class="line">     current = current.<span class="property">next</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> current.<span class="property">data</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>get方法较为简单，就是根据index一直往后找，当index等于传入的position的时候就代表找到了，那么我们直接返回这个元素的值即可。同样的，我们也是定义一个current来保存当前元素，如果当前的位置不对，我就去找current的下一个元素就好了。</p><h3 id="实现indexOf方法"><a href="#实现indexOf方法" class="headerlink" title="实现indexOf方法"></a>实现indexOf方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回指定元素的下标</span></span><br><span class="line"><span class="title function_">indexOf</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  <span class="keyword">while</span> (current) &#123;</span><br><span class="line">    <span class="keyword">if</span> (current.<span class="property">data</span> === data) &#123;</span><br><span class="line">      <span class="keyword">return</span> index;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      current = current.<span class="property">next</span>;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和get方法类似，判断当前current的data是不是等于传进来的data，如果是就代表找到了，那么我们就返回这个index出去，如果不是就继续找。最后没找到的话就返回-1就可</p><h3 id="实现update方法"><a href="#实现update方法" class="headerlink" title="实现update方法"></a>实现update方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 更新指定位置的元素</span></span><br><span class="line"><span class="title function_">update</span>(<span class="params">position, data</span>) &#123;</span><br><span class="line">  <span class="comment">// 判断位置小于0或者是位置大于长度，那就直接返回false，表示没找到</span></span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//找到了就更新数据</span></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  <span class="keyword">while</span> (index &lt; position) &#123;</span><br><span class="line">    current = current.<span class="property">next</span>;</span><br><span class="line">    index++;</span><br><span class="line">  &#125;</span><br><span class="line">  current.<span class="property">data</span> = data;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和前面的逻辑类似，只是在找到的时候将传进来的data赋值给current的data</p><h3 id="实现removeAt方法"><a href="#实现removeAt方法" class="headerlink" title="实现removeAt方法"></a>实现removeAt方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除指定位置的元素</span></span><br><span class="line"><span class="title function_">removeAt</span>(<span class="params">position</span>) &#123;</span><br><span class="line">  <span class="comment">// 边缘判断</span></span><br><span class="line">  <span class="keyword">if</span> (position &lt; <span class="number">0</span> || position &gt;= <span class="variable language_">this</span>.<span class="property">length</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 删除指定元素</span></span><br><span class="line">  <span class="comment">// 判断是否删除的第一个节点</span></span><br><span class="line">  <span class="keyword">let</span> index = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">let</span> current = <span class="variable language_">this</span>.<span class="property">head</span>;</span><br><span class="line">  <span class="keyword">let</span> prive = <span class="literal">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (position === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">head</span> = current.<span class="property">next</span>;</span><br><span class="line">    current = <span class="literal">null</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">while</span> (index &lt; position) &#123;</span><br><span class="line">      prive = current;</span><br><span class="line">      current = current.<span class="property">next</span>;</span><br><span class="line">      index++;</span><br><span class="line">    &#125;</span><br><span class="line">    prive.<span class="property">next</span> = current.<span class="property">next</span>;</span><br><span class="line">    <span class="comment">// 这里不置为null也不影响打印，但是都没用了，你还要留在哪来干什么，没必要</span></span><br><span class="line">    current = <span class="literal">null</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">length</span>--;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除元素也需要分情况，如果删除的是第一个元素，那么我们直接this.head指向原本的第二个元素就好，否则就按照逻辑继续删除即可，跟插入一样，需要先保存上一个元素和下一个元素。</p><blockquote><p>删除元素有个点：如果不将删除的那个元素置为空，其实也不影响代码的执行。因为链接在查询的时候是按照next来一个个找的，我们已经没有next指向他了，但是我觉得既然没用了，何必保存着这个元素对象呢？当然因为没有人指向他，你也可以等待js的垃圾回收机制过来回收清除</p></blockquote><h3 id="实现remove方法"><a href="#实现remove方法" class="headerlink" title="实现remove方法"></a>实现remove方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 删除某一项</span></span><br><span class="line"><span class="title function_">remove</span>(<span class="params">data</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> index = <span class="variable language_">this</span>.<span class="title function_">indexOf</span>(data);</span><br><span class="line">  <span class="keyword">if</span> (index !== -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">removeAt</span>(index);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>删除指定元素比较简单，如果我们之前的方法封装的好，我们只需要调用indexOf找到这个元素的下标，然后根据这个元素的下标调用removeAt方法即可</p><h3 id="首先isEmpty方法"><a href="#首先isEmpty方法" class="headerlink" title="首先isEmpty方法"></a>首先isEmpty方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否为空</span></span><br><span class="line"><span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span> === <span class="number">0</span> ? <span class="literal">true</span> : <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们在LinkedList类定义的length属性就派上用场了，我们只需要判断下长度登不等于0即可</p><h3 id="实现size方法"><a href="#实现size方法" class="headerlink" title="实现size方法"></a>实现size方法</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回链表长度</span></span><br><span class="line"><span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">length</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>直接将length属性返回出去即可</p>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>优先级队列</title>
      <link href="/post/a21107fc.html"/>
      <url>/post/a21107fc.html</url>
      
        <content type="html"><![CDATA[<h1 id="优先级队列"><a href="#优先级队列" class="headerlink" title="优先级队列"></a>优先级队列</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p><strong>优先队列</strong>是计算机科学中的一类抽象数据类型。优先队列中的每个元素都有各自的优先级，优先级最高的元素最先得到服务；优先级相同的元素按照其在优先队列中的顺序得到服务。优先队列往往用堆来实现。还是那句话，维基百科喜欢用概念解释概念，简而言之：正常的队列，插入一个元素，都会放到后端，优先级队列需要在插入元素的时候考虑这个数据的优先级，然后和别的元素比较优先级，最后得出这个元素在队列中正确的位置。</p><h2 id="在js中实现优先级队列"><a href="#在js中实现优先级队列" class="headerlink" title="在js中实现优先级队列"></a>在js中实现优先级队列</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 因为我们每个元素都是一个对象，要包含本身的值，还有他的优先级，所以定义一个构造函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">QueueElement</span>(<span class="params">item, priority</span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">_item</span> = item;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">priority</span> = priority;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">PriorityQueue</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span> = [];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title class_">PriorityQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">enqueue</span> = <span class="keyword">function</span> (<span class="params">element, priority</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> queueElement = <span class="keyword">new</span> <span class="title class_">QueueElement</span>(element, priority);</span><br><span class="line">  <span class="keyword">if</span> (<span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> === <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(queueElement);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> index = <span class="number">0</span>; index &lt; <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span>; index++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (queueElement.<span class="property">priority</span> &lt; <span class="variable language_">this</span>.<span class="property">items</span>[index].<span class="property">priority</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">splice</span>(index, <span class="number">0</span>, queueElement);</span><br><span class="line">        flag = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!flag) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(queueElement);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">PriorityQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">dequeue</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">shift</span>();</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">PriorityQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">front</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">PriorityQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">isEmpty</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">PriorityQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">size</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">PriorityQueue</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">toString</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    str = str + item.<span class="property">priority</span> + <span class="string">&quot;-&quot;</span> + item.<span class="property">_item</span> + <span class="string">&quot; &quot;</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">return</span> str;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p1 = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>();</span><br><span class="line">p1.<span class="title function_">enqueue</span>(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line">p1.<span class="title function_">enqueue</span>(<span class="number">4</span>, <span class="number">4</span>);</span><br><span class="line">p1.<span class="title function_">enqueue</span>(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line">p1.<span class="title function_">enqueue</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">p1.<span class="title function_">enqueue</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">p1.<span class="title function_">enqueue</span>(<span class="number">100</span>, <span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">p1.<span class="title function_">enqueue</span>(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(p1.<span class="title function_">toString</span>());</span><br></pre></td></tr></table></figure><ol><li>我们在插入元素的时候需要指定当前元素的值还有他的优先级，所以我们生命一个构造函数。</li><li>然后分三种情况<ul><li>第一种情况，第一次插入的时候就没必要比较的，直接插入即可</li><li>第二种情况，items里面有元素，我们需要根据当前元素的优先级来插入这个元素</li><li>第三种情况，items元素遍历完了都没找到，说明他应该插入最后端，那么我们就直接push进去就完事了</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>队列结构</title>
      <link href="/post/4c563ed0.html"/>
      <url>/post/4c563ed0.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构之队列结构"><a href="#数据结构之队列结构" class="headerlink" title="数据结构之队列结构"></a>数据结构之队列结构</h1><h3 id="基本定义"><a href="#基本定义" class="headerlink" title="基本定义"></a>基本定义</h3><p>队列结构是一种受限的数据结构，它是一种线性表，符合先进先出的特点(FIFO—-&gt; First In First Out)。受限之处是因为他只允许在前端进行删除操作，在后端进行插入操作。比如说我们日常生活中的排队，有限排队的人优先处理。</p><h3 id="在JavaScript中实现队列结构"><a href="#在JavaScript中实现队列结构" class="headerlink" title="在JavaScript中实现队列结构"></a>在JavaScript中实现队列结构</h3><p>实现队列结构可以通过数组实现，也可以基于链表实现，采用数组实现效率不高，因为我们删除了第一个元素，会导致后面的所有元素都要往前面移一位，但是还没有学习到链表，于是我们就采取熟悉的数组实现。</p><h4 id="队列的常见操作"><a href="#队列的常见操作" class="headerlink" title="队列的常见操作"></a>队列的常见操作</h4><ol><li>enqueue：向队列尾部添加一个或多个项</li><li>dequeue：移除队列第一个项，也是需要删除的哪一项，并且返回被删除的元素</li><li>front：返回队列的第一个元素，队列不做任何操作，单纯的看一眼会被移除的元素</li><li>isEmpty：如果队列为空则返回true，反之返回false</li><li>size：返回队列中的元素个数</li><li>toString：将队列的元素转换为字符串</li></ol><h4 id="利用数组实现队列结构"><a href="#利用数组实现队列结构" class="headerlink" title="利用数组实现队列结构"></a>利用数组实现队列结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">shift</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">front</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      str = str + item + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br></pre></td></tr></table></figure><h3 id="击鼓传花案例"><a href="#击鼓传花案例" class="headerlink" title="击鼓传花案例"></a>击鼓传花案例</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Queue</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">enqueue</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">dequeue</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">shift</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">front</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      str = str + item + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//封装函数</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">cuurent</span>(<span class="params">playerList, number</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> queue = <span class="keyword">new</span> <span class="title class_">Queue</span>();</span><br><span class="line">  playerList.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">    queue.<span class="title function_">enqueue</span>(item);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="keyword">while</span> (!(queue.<span class="title function_">size</span>() === <span class="number">1</span>)) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; number - <span class="number">1</span>; i++) &#123;</span><br><span class="line">      queue.<span class="title function_">enqueue</span>(queue.<span class="title function_">dequeue</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    queue.<span class="title function_">dequeue</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> queue.<span class="title function_">front</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义需要传入的数组</span></span><br><span class="line"><span class="keyword">const</span> playerList = [</span><br><span class="line">  <span class="string">&quot;amy&quot;</span>,</span><br><span class="line">  <span class="string">&quot;doinb&quot;</span>,</span><br><span class="line">  <span class="string">&quot;coderwei&quot;</span>,</span><br><span class="line">  <span class="string">&quot;zys&quot;</span>,</span><br><span class="line">  <span class="string">&quot;jacker&quot;</span>,</span><br><span class="line">  <span class="string">&quot;join&quot;</span>,</span><br><span class="line">  <span class="string">&quot;rokkie&quot;</span>,</span><br><span class="line">  <span class="string">&quot;bin&quot;</span>,</span><br><span class="line">  <span class="string">&quot;faker&quot;</span>,</span><br><span class="line">  <span class="string">&quot;the shy&quot;</span>,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">cuurent</span>(playerList, <span class="number">5</span>)); <span class="comment">//coderwei</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>栈结构</title>
      <link href="/post/d54abf1c.html"/>
      <url>/post/d54abf1c.html</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构之栈结构"><a href="#数据结构之栈结构" class="headerlink" title="数据结构之栈结构"></a>数据结构之栈结构</h1><h3 id="基本定义："><a href="#基本定义：" class="headerlink" title="基本定义："></a>基本定义：</h3><p>只允许在有序的线性资料集合的一端（称为堆栈顶端，top）进行加入数据（push）和移除数据（pop）的运算。它有两种基本操作：推入或者弹出，遵循着先入后出，后入先出的特点。</p><h3 id="在javascript中实现栈结构"><a href="#在javascript中实现栈结构" class="headerlink" title="在javascript中实现栈结构"></a>在javascript中实现栈结构</h3><p>在javascript中实现栈结构，最常见的就是借助数组来实现，数组中提供了push和pop方法，可以很轻松的实现栈结构的特点。</p><h4 id="栈结构的常用操作"><a href="#栈结构的常用操作" class="headerlink" title="栈结构的常用操作"></a>栈结构的常用操作</h4><ol><li><p>push：添加一个新元素到栈顶</p></li><li><p>pop：移除栈顶的元素，同时返回被移除的元素</p></li><li><p>peek：返回栈顶的元素，不对栈做任何修改，单纯的看一眼栈顶是谁</p></li><li><p>isEmpty：如果栈里没有元素就返回true，反之返回false</p></li><li><p>size：返回栈里元素的个数</p></li><li><p>toString：将栈结构的内容以字符串的形式返回</p></li></ol><h4 id="利用数组实现栈结构"><a href="#利用数组实现栈结构" class="headerlink" title="利用数组实现栈结构"></a>利用数组实现栈结构</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Stack</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span> = [];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">push</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">push</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">pop</span>(<span class="params">item</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">pop</span>(item);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">peek</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>[<span class="number">0</span>];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">isEmpty</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span> &gt; <span class="number">0</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">size</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">items</span>.<span class="property">length</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">toString</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">items</span>.<span class="title function_">forEach</span>(<span class="function"><span class="params">item</span> =&gt;</span> &#123;</span><br><span class="line">      str = str + item + <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">return</span> str;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br></pre></td></tr></table></figure><h3 id="实现十进制转换成二进制"><a href="#实现十进制转换成二进制" class="headerlink" title="实现十进制转换成二进制"></a>实现十进制转换成二进制</h3><p>在实现之前要了解一点理论知识，十进制转换成二进制是怎么转换的？如果过程都不知道，自然不可能将其转换为代码了。</p><p>十进制是我们日常生活中最常见的，二进制则是我们计算机底层的实现，类似于电路的开和关，也就对应着0和1，比如说100我们该如何转换成二进制呢？首先我们将100除于2然后去余数，然后得到50和余数0，然后继续拿50除于2，得到25和余数0，继续拿25除于2，得到12.5和余数1，12.5我们直接向下取整，得到12，然后继续拿12除于2，得到6和余数0，以此类推，最后我们反向将得到的余数拼在一起，最后得到110 0100。</p><p>既然知道了十进制转换成二进制的过程，接下来我们用代码对其进行复现</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">dec2bin</span>(<span class="params">number</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> stack = <span class="keyword">new</span> <span class="title class_">Stack</span>();</span><br><span class="line">  <span class="comment">// 只要number&gt; 0就继续求余数</span></span><br><span class="line">  <span class="keyword">while</span> (number &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    stack.<span class="title function_">push</span>(number % <span class="number">2</span>);</span><br><span class="line">    number = <span class="title class_">Math</span>.<span class="title function_">floor</span>(number / <span class="number">2</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//从栈中挨个取出元素，然后拼接在一起</span></span><br><span class="line">  <span class="keyword">let</span> bin = <span class="string">&quot;&quot;</span>;</span><br><span class="line">  <span class="keyword">while</span> (!stack.<span class="title function_">isEmpty</span>()) &#123;</span><br><span class="line">    bin += stack.<span class="title function_">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> bin;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>React的setState详解</title>
      <link href="/post/473e4a1c.html"/>
      <url>/post/473e4a1c.html</url>
      
        <content type="html"><![CDATA[<h3 id="为什么需要setState方法"><a href="#为什么需要setState方法" class="headerlink" title="为什么需要setState方法"></a>为什么需要setState方法</h3><p>​        首先我们需要知道，React不同于Vue，他并没有实现Vue的响应式原理，我们需要手动的调用setState方法修改数据通知React进行更新界面</p><h3 id="setState方法数据的合并"><a href="#setState方法数据的合并" class="headerlink" title="setState方法数据的合并"></a>setState方法数据的合并</h3><p>首先需要知道，setState在执行的时候，并不是覆盖原来的state，而是合并，看下面例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">name</span>:<span class="string">&#x27;coderwei&#x27;</span>,</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&quot;13&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">change</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">    &#125;); </span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;this.state.message&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;this.state.name&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.change.bind(this)&#125;</span>&gt;</span>改变state<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//我们会发现，name属性并没有消失，他依旧显示在界面上，所以在我们在使用setState的时候并不需要手动的进行一次拷贝，然后在将整个对象放到setState里面</span></span><br></pre></td></tr></table></figure><h3 id="setState方法是同步的还是异步的"><a href="#setState方法是同步的还是异步的" class="headerlink" title="setState方法是同步的还是异步的"></a>setState方法是同步的还是异步的</h3><p>setState并没有绝对的同步或者是异步，他在不同的场景下表现是不同的，首先先看个例子</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&quot;13&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">change</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">message</span>)<span class="comment">//输出的是13  </span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;this.state.message&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.change.bind(this)&#125;</span>&gt;</span>改变state<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>上述场景就可以证明setState是一个异步方法，明明我们在输出之前就已经修改了message的代码，但是输出的依旧是修改之前的值</p><h3 id="为什么setState是异步的"><a href="#为什么setState是异步的" class="headerlink" title="为什么setState是异步的"></a>为什么setState是异步的</h3><p>​        明确他是异步的之后，我们就需要知道为什么？了解真相才能获得真正的自由，首先贴一个链接，redux作者 Dan Abramov<a href="https://github.com/facebook/react/issues/11527">对这个方法是同步还是异步的回应</a>，大概在四分之一的位置。</p><ol><li>首先，如果setState方法不是异步的，会导致一个很明显的问题，那就是render函数会频繁的会调用，这样子效率是非常低下的，所以react内部将多个setState维护到一个队列中，然后一起进行更新，在其中如果key相同的则会进行覆盖，这样就大大的提升了性能。</li><li>其次，如果setState是同步的，那么会出现一个问题，也是上面redux作者回应举的一个例子，当setState执行完毕之后，可能App组件的render函数还没有调用完，如果里面用到了其他组件并且其他组件依赖message，那么就会导致state和props的数据不一致，这在开发中可能会导致出现很多问题</li></ol><h3 id="在setState异步的情况下，如何获取跟新后的数据"><a href="#在setState异步的情况下，如何获取跟新后的数据" class="headerlink" title="在setState异步的情况下，如何获取跟新后的数据"></a>在setState异步的情况下，如何获取跟新后的数据</h3><p>​        如果我们需要获取setState更新后的数据，那么setState的第二个参数就派上用场了，setState第二个参数是一个回调函数，当setState执行完毕后会执行这个回调，例如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&quot;13&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">change</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;state的回调:&quot;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">message</span>); <span class="comment">//hello</span></span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;this.state.message&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.change.bind(this)&#125;</span>&gt;</span>改变state<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="同步的setState"><a href="#同步的setState" class="headerlink" title="同步的setState"></a>同步的setState</h3><p>当我们将setState丢在一个定时器内部，这个时候setState就会变成一段同步代码,因为当代码块执行到setTimeout的时候，并没有去执行，而是将他丢到一个任务队列里。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">message</span>: <span class="string">&quot;13&quot;</span>,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">change</span>(<span class="params"></span>) &#123;</span><br><span class="line">   <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="attr">message</span>: <span class="string">&quot;hello&quot;</span>,</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;state的回调:&quot;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">message</span>); <span class="comment">//hello</span></span><br><span class="line">      &#125;</span><br><span class="line">    );</span><br><span class="line">     <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;方法里面的输出&quot;</span>, <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">message</span>); <span class="comment">//hello</span></span><br><span class="line">     &#125;, <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">h2</span>&gt;</span>&#123;this.state.message&#125;<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.change.bind(this)&#125;</span>&gt;</span>改变state<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="不建议直接修改state的数据"><a href="#不建议直接修改state的数据" class="headerlink" title="不建议直接修改state的数据"></a>不建议直接修改state的数据</h3><p>​        在react里，不建议直接修改state的值，官方称  <a href="https://zh-hans.reactjs.org/docs/optimizing-performance.html#the-power-of-not-mutating-data">不可变的力量</a>，如果我们书写代码都是继承自Component，那么其实修改也没有任何问题，不建议修改state的值，是为了考虑到性能优化，我们在父组件修改了一个属性，父组件重新渲染，也会导致子组件的内容重新渲染，这并不是我们希望看到的，你父组件修改个属性，跟我子组件有什么关系，我又不依赖你修改的这个属性，我是保持不变的，重新渲染就太浪费性能了，于是shouldComponentUpdate这个生命周期就派上用场了</p><p>​        shouldComponentUpdate是控制组件是否执行render函数的，他默认返回true，就是无论什么情况下都执行render函数，于是我们就可以在这上面下手，我们可以判断，我子组件的props 是否和父组件的state保持一致，保持一致的话就代表数据没有发生变化，我就不需要执行render刷新界面。shouldComponentUpdate在实际开发中用的还是蛮频繁的。文字总是苍白无力的，还是用代码来表述。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  change = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">arr</span>.<span class="title function_">push</span>(<span class="number">6</span>);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">arr</span>: <span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">arr</span>,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">shouldComponentUpdate</span>(<span class="params">newProps, newState</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(newState);  <span class="comment">//[1,2,3,4,5,6]</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">arr</span>);<span class="comment">//[1,2,3,4,5,6]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.state.arr.map(item =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">          return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>;</span></span><br><span class="line"><span class="language-xml">        &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.change&#125;</span>&gt;</span>=1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​        每次点击按钮，最新的state和当前组件实例对象的state是一模一样的，因为javascript中复杂数据类型保存的是内存地址，也就是说他们保存的都是一个对象的引用，最后他们指向的都是同一个对象，于是他们就永远保持一致，这样就没办法判断state有没有发生变化，因为我们需要通过state的变化来判断界面需不需要重新渲染。</p><p>​        所以上面的代码我们稍微修改一下，不去直接修改state的值，而是创建一个新的arr数组，然后赋值给arr</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="title class_">React</span>, &#123; <span class="title class_">Component</span> &#125; <span class="keyword">from</span> <span class="string">&quot;react&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="keyword">class</span> <span class="title class_">App</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Component</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">props</span>) &#123;</span><br><span class="line">    <span class="variable language_">super</span>(props);</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">state</span> = &#123;</span><br><span class="line">      <span class="attr">arr</span>: [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  change = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">let</span> newArr = [...<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">arr</span>, <span class="number">6</span>];</span><br><span class="line">    <span class="variable language_">this</span>.<span class="title function_">setState</span>(&#123;</span><br><span class="line">      <span class="attr">arr</span>: newArr,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="title function_">shouldComponentUpdate</span>(<span class="params">newProps, newState</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>( newState); <span class="comment">//[1,2,3,4,5,6]</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">state</span>.<span class="property">arr</span>); <span class="comment">//[1,2,3,4,5]</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">render</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">        &#123;this.state.arr.map(item =&gt; &#123;</span></span><br><span class="line"><span class="language-xml">          return <span class="tag">&lt;<span class="name">li</span> <span class="attr">key</span>=<span class="string">&#123;item&#125;</span>&gt;</span>&#123;item&#125;<span class="tag">&lt;/<span class="name">li</span>&gt;</span>;</span></span><br><span class="line"><span class="language-xml">        &#125;)&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;this.change&#125;</span>&gt;</span>=1<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>我们就可以在shouldComponentUpdate中判断，如果新的state和当前对象的state保持一致，那我们就不需要执行render函数渲染界面，这样就可以极大程度上避免毫无意义的render函数的执行</p>]]></content>
      
      
      <categories>
          
          <category> React </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
